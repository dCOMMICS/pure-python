/**
 * Throws an error if multiple copies of a Liveblocks package are being loaded
 * at runtime. This likely indicates a packaging issue with the project.
 */
declare function detectDupes(pkgName: string, pkgVersion: string | false, // false if not built yet
pkgFormat: string | false): void;

/**
 * Represents an indefinitely deep arbitrary JSON data structure. There are
 * four types that make up the Json family:
 *
 * - Json         any legal JSON value
 * - JsonScalar   any legal JSON leaf value (no lists or objects)
 * - JsonArray    a JSON value whose outer type is an array
 * - JsonObject   a JSON value whose outer type is an object
 *
 */
declare type Json = JsonScalar | JsonArray | JsonObject;
declare type JsonScalar = string | number | boolean | null;
declare type JsonArray = Json[];
declare type JsonObject = {
    [key: string]: Json | undefined;
};
declare function isJsonScalar(data: Json): data is JsonScalar;
declare function isJsonArray(data: Json): data is JsonArray;
declare function isJsonObject(data: Json): data is JsonObject;

declare enum OpCode {
    INIT = 0,
    SET_PARENT_KEY = 1,
    CREATE_LIST = 2,
    UPDATE_OBJECT = 3,
    CREATE_OBJECT = 4,
    DELETE_CRDT = 5,
    DELETE_OBJECT_KEY = 6,
    CREATE_MAP = 7,
    CREATE_REGISTER = 8
}
/**
 * These operations are the payload for {@link UpdateStorageServerMsg} messages
 * only.
 */
declare type Op = AckOp | CreateOp | UpdateObjectOp | DeleteCrdtOp | SetParentKeyOp | DeleteObjectKeyOp;
declare type CreateOp = CreateRootObjectOp | CreateChildOp;
declare type CreateChildOp = CreateObjectOp | CreateRegisterOp | CreateMapOp | CreateListOp;
declare type UpdateObjectOp = {
    readonly opId?: string;
    readonly id: string;
    readonly type: OpCode.UPDATE_OBJECT;
    readonly data: Partial<JsonObject>;
};
declare type CreateObjectOp = {
    readonly opId?: string;
    readonly id: string;
    readonly intent?: "set";
    readonly deletedId?: string;
    readonly type: OpCode.CREATE_OBJECT;
    readonly parentId: string;
    readonly parentKey: string;
    readonly data: JsonObject;
};
declare type CreateRootObjectOp = {
    readonly opId?: string;
    readonly id: string;
    readonly type: OpCode.CREATE_OBJECT;
    readonly data: JsonObject;
    readonly parentId?: never;
    readonly parentKey?: never;
};
declare type CreateListOp = {
    readonly opId?: string;
    readonly id: string;
    readonly intent?: "set";
    readonly deletedId?: string;
    readonly type: OpCode.CREATE_LIST;
    readonly parentId: string;
    readonly parentKey: string;
};
declare type CreateMapOp = {
    readonly opId?: string;
    readonly id: string;
    readonly intent?: "set";
    readonly deletedId?: string;
    readonly type: OpCode.CREATE_MAP;
    readonly parentId: string;
    readonly parentKey: string;
};
declare type CreateRegisterOp = {
    readonly opId?: string;
    readonly id: string;
    readonly intent?: "set";
    readonly deletedId?: string;
    readonly type: OpCode.CREATE_REGISTER;
    readonly parentId: string;
    readonly parentKey: string;
    readonly data: Json;
};
declare type DeleteCrdtOp = {
    readonly opId?: string;
    readonly id: string;
    readonly type: OpCode.DELETE_CRDT;
};
declare type AckOp = {
    readonly type: OpCode.DELETE_CRDT;
    readonly id: "ACK";
    readonly opId: string;
};
declare type SetParentKeyOp = {
    readonly opId?: string;
    readonly id: string;
    readonly type: OpCode.SET_PARENT_KEY;
    readonly parentKey: string;
};
declare type DeleteObjectKeyOp = {
    readonly opId?: string;
    readonly id: string;
    readonly type: OpCode.DELETE_OBJECT_KEY;
    readonly key: string;
};

/**
 * Represents an indefinitely deep arbitrary immutable data
 * structure, as returned by the .toImmutable().
 */
declare type Immutable = Scalar | ImmutableList | ImmutableObject | ImmutableMap;
declare type Scalar = string | number | boolean | null;
declare type ImmutableList = readonly Immutable[];
declare type ImmutableObject = {
    readonly [key: string]: Immutable | undefined;
};
declare type ImmutableMap = ReadonlyMap<string, Immutable>;

declare type UpdateDelta = {
    type: "update";
} | {
    type: "delete";
};

/**
 * "Plain LSON" is a JSON-based format that's used when serializing Live structures
 * to send them over HTTP (e.g. in the API endpoint to let users upload their initial
 * Room storage, in the API endpoint to fetch a Room's storage, ...).
 *
 * In the client, you would typically create LSON values using:
 *
 *    new LiveObject({ x: 0, y: 0 })
 *
 * But over HTTP, this has to be serialized somehow. The "Plain LSON" format
 * is what's used in the POST /init-storage-new endpoint, to allow users to
 * control which parts of their data structure should be considered "Live"
 * objects, and which parts are "normal" objects.
 *
 * So if they have a structure like:
 *
 *    { x: 0, y: 0 }
 *
 * And want to make it a Live object, they can serialize it by wrapping it in
 * a special "annotation":
 *
 *    {
 *      "liveblocksType": "LiveObject",
 *      "data": { x: 0, y: 0 },
 *    }
 *
 * This "Plain LSON" data format defines exactly those wrappings.
 *
 * To summarize:
 *
 *   LSON value            |  Plain LSON equivalent
 *   ----------------------+----------------------------------------------
 *   42                    |  42
 *   [1, 2, 3]             |  [1, 2, 3]
 *   { x: 0, y: 0 }        |  { x: 0, y: 0 }
 *   ----------------------+----------------------------------------------
 *   new LiveList(...)     |  { liveblocksType: "LiveList",   data: ... }
 *   new LiveMap(...)      |  { liveblocksType: "LiveMap",    data: ... }
 *   new LiveObject(...)   |  { liveblocksType: "LiveObject", data: ... }
 *
 */

declare type PlainLsonFields = Record<string, PlainLson>;
declare type PlainLsonObject = {
    liveblocksType: "LiveObject";
    data: PlainLsonFields;
};
declare type PlainLsonMap = {
    liveblocksType: "LiveMap";
    data: PlainLsonFields;
};
declare type PlainLsonList = {
    liveblocksType: "LiveList";
    data: PlainLson[];
};
declare type PlainLson = PlainLsonObject | PlainLsonMap | PlainLsonList | Json;

declare type LiveObjectUpdateDelta<O extends {
    [key: string]: unknown;
}> = {
    [K in keyof O]?: UpdateDelta | undefined;
};
/**
 * A LiveObject notification that is sent in-client to any subscribers whenever
 * one or more of the entries inside the LiveObject instance have changed.
 */
declare type LiveObjectUpdates<TData extends LsonObject> = {
    type: "LiveObject";
    node: LiveObject<TData>;
    updates: LiveObjectUpdateDelta<TData>;
};
/**
 * The LiveObject class is similar to a JavaScript object that is synchronized on all clients.
 * Keys should be a string, and values should be serializable to JSON.
 * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.
 */
declare class LiveObject<O extends LsonObject> extends AbstractCrdt {
    constructor(obj?: O);
    /**
     * Transform the LiveObject into a javascript object
     */
    toObject(): O;
    /**
     * Adds or updates a property with a specified key and a value.
     * @param key The key of the property to add
     * @param value The value of the property to add
     */
    set<TKey extends keyof O>(key: TKey, value: O[TKey]): void;
    /**
     * Returns a specified property from the LiveObject.
     * @param key The key of the property to get
     */
    get<TKey extends keyof O>(key: TKey): O[TKey];
    /**
     * Deletes a key from the LiveObject
     * @param key The key of the property to delete
     */
    delete(key: keyof O): void;
    /**
     * Adds or updates multiple properties at once with an object.
     * @param patch The object used to overrides properties
     */
    update(patch: Partial<O>): void;
    toImmutable(): ToImmutable<O>;
}

/**
 * Helper type to convert any valid Lson type to the equivalent Json type.
 *
 * Examples:
 *
 *   ToImmutable<42>                         // 42
 *   ToImmutable<'hi'>                       // 'hi'
 *   ToImmutable<number>                     // number
 *   ToImmutable<string>                     // string
 *   ToImmutable<string | LiveList<number>>  // string | readonly number[]
 *   ToImmutable<LiveMap<string, LiveList<number>>>
 *                                           // ReadonlyMap<string, readonly number[]>
 *   ToImmutable<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>
 *                                           // { readonly a: null, readonly b: readonly string[], readonly c?: number }
 *
 */
declare type ToImmutable<L extends Lson | LsonObject> = L extends LiveList<infer I> ? readonly ToImmutable<I>[] : L extends LiveObject<infer O> ? ToImmutable<O> : L extends LiveMap<infer K, infer V> ? ReadonlyMap<K, ToImmutable<V>> : L extends LsonObject ? {
    readonly [K in keyof L]: ToImmutable<Exclude<L[K], undefined>> | (undefined extends L[K] ? undefined : never);
} : L extends Json ? L : never;
/**
 * Returns PlainLson for a given Json or LiveStructure, suitable for calling the storage init api
 */
declare function toPlainLson(lson: Lson): PlainLson;

/**
 * A LiveMap notification that is sent in-client to any subscribers whenever
 * one or more of the values inside the LiveMap instance have changed.
 */
declare type LiveMapUpdates<TKey extends string, TValue extends Lson> = {
    type: "LiveMap";
    node: LiveMap<TKey, TValue>;
    updates: {
        [key: string]: UpdateDelta;
    };
};
/**
 * The LiveMap class is similar to a JavaScript Map that is synchronized on all clients.
 * Keys should be a string, and values should be serializable to JSON.
 * If multiple clients update the same property simultaneously, the last modification received by the Liveblocks servers is the winner.
 */
declare class LiveMap<TKey extends string, TValue extends Lson> extends AbstractCrdt {
    constructor(entries?: readonly (readonly [TKey, TValue])[] | undefined);
    /**
     * Returns a specified element from the LiveMap.
     * @param key The key of the element to return.
     * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.
     */
    get(key: TKey): TValue | undefined;
    /**
     * Adds or updates an element with a specified key and a value.
     * @param key The key of the element to add. Should be a string.
     * @param value The value of the element to add. Should be serializable to JSON.
     */
    set(key: TKey, value: TValue): void;
    /**
     * Returns the number of elements in the LiveMap.
     */
    get size(): number;
    /**
     * Returns a boolean indicating whether an element with the specified key exists or not.
     * @param key The key of the element to test for presence.
     */
    has(key: TKey): boolean;
    /**
     * Removes the specified element by key.
     * @param key The key of the element to remove.
     * @returns true if an element existed and has been removed, or false if the element does not exist.
     */
    delete(key: TKey): boolean;
    /**
     * Returns a new Iterator object that contains the [key, value] pairs for each element.
     */
    entries(): IterableIterator<[TKey, TValue]>;
    /**
     * Same function object as the initial value of the entries method.
     */
    [Symbol.iterator](): IterableIterator<[TKey, TValue]>;
    /**
     * Returns a new Iterator object that contains the keys for each element.
     */
    keys(): IterableIterator<TKey>;
    /**
     * Returns a new Iterator object that contains the values for each element.
     */
    values(): IterableIterator<TValue>;
    /**
     * Executes a provided function once per each key/value pair in the Map object, in insertion order.
     * @param callback Function to execute for each entry in the map.
     */
    forEach(callback: (value: TValue, key: TKey, map: LiveMap<TKey, TValue>) => void): void;
    toImmutable(): ReadonlyMap<TKey, ToImmutable<TValue>>;
}

declare type StorageCallback = (updates: StorageUpdate[]) => void;
declare type LiveMapUpdate = LiveMapUpdates<string, Lson>;
declare type LiveObjectUpdate = LiveObjectUpdates<LsonObject>;
declare type LiveListUpdate = LiveListUpdates<Lson>;
/**
 * The payload of notifications sent (in-client) when LiveStructures change.
 * Messages of this kind are not originating from the network, but are 100%
 * in-client.
 */
declare type StorageUpdate = LiveMapUpdate | LiveObjectUpdate | LiveListUpdate;

declare abstract class AbstractCrdt {
    get roomId(): string | null;
    /**
     * Return an immutable snapshot of this Live node and its children.
     */
    toImmutable(): Immutable;
}

declare type LiveListUpdateDelta = {
    index: number;
    item: Lson;
    type: "insert";
} | {
    index: number;
    type: "delete";
} | {
    index: number;
    previousIndex: number;
    item: Lson;
    type: "move";
} | {
    index: number;
    item: Lson;
    type: "set";
};
/**
 * A LiveList notification that is sent in-client to any subscribers whenever
 * one or more of the items inside the LiveList instance have changed.
 */
declare type LiveListUpdates<TItem extends Lson> = {
    type: "LiveList";
    node: LiveList<TItem>;
    updates: LiveListUpdateDelta[];
};
/**
 * The LiveList class represents an ordered collection of items that is synchronized across clients.
 */
declare class LiveList<TItem extends Lson> extends AbstractCrdt {
    constructor(items?: TItem[]);
    /**
     * Returns the number of elements.
     */
    get length(): number;
    /**
     * Adds one element to the end of the LiveList.
     * @param element The element to add to the end of the LiveList.
     */
    push(element: TItem): void;
    /**
     * Inserts one element at a specified index.
     * @param element The element to insert.
     * @param index The index at which you want to insert the element.
     */
    insert(element: TItem, index: number): void;
    /**
     * Move one element from one index to another.
     * @param index The index of the element to move
     * @param targetIndex The index where the element should be after moving.
     */
    move(index: number, targetIndex: number): void;
    /**
     * Deletes an element at the specified index
     * @param index The index of the element to delete
     */
    delete(index: number): void;
    clear(): void;
    set(index: number, item: TItem): void;
    /**
     * Returns an Array of all the elements in the LiveList.
     */
    toArray(): TItem[];
    /**
     * Tests whether all elements pass the test implemented by the provided function.
     * @param predicate Function to test for each element, taking two arguments (the element and its index).
     * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.
     */
    every(predicate: (value: TItem, index: number) => unknown): boolean;
    /**
     * Creates an array with all elements that pass the test implemented by the provided function.
     * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.
     * @returns An array with the elements that pass the test.
     */
    filter(predicate: (value: TItem, index: number) => unknown): TItem[];
    /**
     * Returns the first element that satisfies the provided testing function.
     * @param predicate Function to execute on each value.
     * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.
     */
    find(predicate: (value: TItem, index: number) => unknown): TItem | undefined;
    /**
     * Returns the index of the first element in the LiveList that satisfies the provided testing function.
     * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.
     * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.
     */
    findIndex(predicate: (value: TItem, index: number) => unknown): number;
    /**
     * Executes a provided function once for each element.
     * @param callbackfn Function to execute on each element.
     */
    forEach(callbackfn: (value: TItem, index: number) => void): void;
    /**
     * Get the element at the specified index.
     * @param index The index on the element to get.
     * @returns The element at the specified index or undefined.
     */
    get(index: number): TItem | undefined;
    /**
     * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.
     * @param searchElement Element to locate.
     * @param fromIndex The index to start the search at.
     * @returns The first index of the element in the LiveList; -1 if not found.
     */
    indexOf(searchElement: TItem, fromIndex?: number): number;
    /**
     * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.
     * @param searchElement Element to locate.
     * @param fromIndex The index at which to start searching backwards.
     * @returns
     */
    lastIndexOf(searchElement: TItem, fromIndex?: number): number;
    /**
     * Creates an array populated with the results of calling a provided function on every element.
     * @param callback Function that is called for every element.
     * @returns An array with each element being the result of the callback function.
     */
    map<U>(callback: (value: TItem, index: number) => U): U[];
    /**
     * Tests whether at least one element in the LiveList passes the test implemented by the provided function.
     * @param predicate Function to test for each element.
     * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.
     */
    some(predicate: (value: TItem, index: number) => unknown): boolean;
    [Symbol.iterator](): IterableIterator<TItem>;
    toImmutable(): readonly ToImmutable<TItem>[];
}

/**
 * INTERNAL
 */
declare class LiveRegister<TValue extends Json> extends AbstractCrdt {
    constructor(data: TValue);
    get data(): TValue;
}

declare type LiveStructure = LiveObject<LsonObject> | LiveList<Lson> | LiveMap<string, Lson>;
/**
 * Think of Lson as a sibling of the Json data tree, except that the nested
 * data structure can contain a mix of Json values and LiveStructure instances.
 */
declare type Lson = Json | LiveStructure;
/**
 * LiveNode is the internal tree for managing Live data structures. The key
 * difference with Lson is that all the Json values get represented in
 * a LiveRegister node.
 */
declare type LiveNode = LiveStructure | LiveRegister<Json>;
/**
 * A mapping of keys to Lson values. A Lson value is any valid JSON
 * value or a Live storage data structure (LiveMap, LiveList, etc.)
 */
declare type LsonObject = {
    [key: string]: Lson | undefined;
};
/**
 * Helper type to convert any valid Lson type to the equivalent Json type.
 *
 * Examples:
 *
 *   ToJson<42>                         // 42
 *   ToJson<'hi'>                       // 'hi'
 *   ToJson<number>                     // number
 *   ToJson<string>                     // string
 *   ToJson<string | LiveList<number>>  // string | number[]
 *   ToJson<LiveMap<string, LiveList<number>>>
 *                                      // { [key: string]: number[] }
 *   ToJson<LiveObject<{ a: number, b: LiveList<string>, c?: number }>>
 *                                      // { a: null, b: string[], c?: number }
 *
 */
declare type ToJson<T extends Lson | LsonObject> = T extends Json ? T : T extends LsonObject ? {
    [K in keyof T]: ToJson<Exclude<T[K], undefined>> | (undefined extends T[K] ? undefined : never);
} : T extends LiveList<infer I> ? ToJson<I>[] : T extends LiveObject<infer O> ? ToJson<O> : T extends LiveMap<infer KS, infer V> ? {
    [K in KS]: ToJson<V>;
} : never;

/**
 * This helper type is effectively a no-op, but will force TypeScript to
 * "evaluate" any named helper types in its definition. This can sometimes make
 * API signatures clearer in IDEs.
 *
 * For example, in:
 *
 *   type Payload<T> = { data: T };
 *
 *   let r1: Payload<string>;
 *   let r2: Resolve<Payload<string>>;
 *
 * The inferred type of `r1` is going to be `Payload<string>` which shows up in
 * editor hints, and it may be unclear what's inside if you don't know the
 * definition of `Payload`.
 *
 * The inferred type of `r2` is going to be `{ data: string }`, which may be
 * more helpful.
 *
 * This trick comes from:
 * https://effectivetypescript.com/2022/02/25/gentips-4-display/
 */
declare type Resolve<T> = T extends (...args: unknown[]) => unknown ? T : {
    [K in keyof T]: T[K];
};

declare type CustomAuthenticationResult = {
    token: string;
    error?: never;
} | {
    token?: never;
    error: "forbidden";
    reason: string;
} | {
    token?: never;
    error: string;
    reason: string;
};

declare type BaseUserInfo = {
    [key: string]: Json | undefined;
    name?: string;
    avatar?: string;
};
/**
 * This type is used by clients to define the metadata for a user.
 */
declare type BaseUserMeta = {
    /**
     * The id of the user that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    id?: string;
    /**
     * Additional user information that has been set in the authentication endpoint.
     */
    info?: BaseUserInfo;
};

declare enum Permission {
    Read = "room:read",
    Write = "room:write",
    PresenceWrite = "room:presence:write",
    CommentsWrite = "comments:write",
    CommentsRead = "comments:read"
}
declare type LiveblocksPermissions = Record<string, Permission[]>;
declare enum TokenKind {
    SECRET_LEGACY = "sec-legacy",
    ACCESS_TOKEN = "acc",
    ID_TOKEN = "id"
}
declare type JwtMeta = {
    iat: number;
    exp: number;
};
/**
 * Legacy Secret Token.
 */
declare type LegacySecretToken = {
    k: TokenKind.SECRET_LEGACY;
    roomId: string;
    scopes: string[];
    id?: string;
    info?: BaseUserInfo;
    [other: string]: Json | undefined;
} & JwtMeta;
/**
 * New authorization Access Token.
 */
declare type AccessToken = {
    k: TokenKind.ACCESS_TOKEN;
    pid: string;
    uid: string;
    perms: LiveblocksPermissions;
    ui?: BaseUserInfo;
} & JwtMeta;
/**
 * New authorization ID Token.
 */
declare type IDToken = {
    k: TokenKind.ID_TOKEN;
    pid: string;
    uid: string;
    gids?: string[];
    ui?: BaseUserInfo;
} & JwtMeta;
declare type AuthToken = AccessToken | IDToken | LegacySecretToken;
declare type ParsedAuthToken = {
    readonly raw: string;
    readonly parsed: AuthToken;
};

declare type AuthValue = {
    type: "secret";
    token: ParsedAuthToken;
} | {
    type: "public";
    publicApiKey: string;
};

declare type BaseMetadata = Record<string, string | boolean | number>;

declare type CommentBodyBlockElement = CommentBodyParagraph;
declare type CommentBodyInlineElement = CommentBodyText | CommentBodyMention | CommentBodyLink;
declare type CommentBodyElement = CommentBodyBlockElement | CommentBodyInlineElement;
declare type CommentBodyParagraph = {
    type: "paragraph";
    children: CommentBodyInlineElement[];
};
declare type CommentBodyMention = {
    type: "mention";
    id: string;
};
declare type CommentBodyLink = {
    type: "link";
    url: string;
};
declare type CommentBodyText = {
    bold?: boolean;
    italic?: boolean;
    strikethrough?: boolean;
    code?: boolean;
    text: string;
};
declare type CommentBody = {
    version: 1;
    content: CommentBodyBlockElement[];
};

declare type CommentReaction = {
    emoji: string;
    userId: string;
    createdAt: string;
};
/**
 * Represents a comment.
 */
declare type CommentData = {
    type: "comment";
    id: string;
    threadId: string;
    roomId: string;
    userId: string;
    createdAt: string;
    editedAt?: string;
    reactions: CommentReaction[];
} & ({
    body: CommentBody;
    deletedAt?: never;
} | {
    body?: never;
    deletedAt: string;
});

/**
 * Represents a thread of comments.
 */
declare type ThreadData<ThreadMetadata extends BaseMetadata = never> = {
    type: "thread";
    id: string;
    roomId: string;
    createdAt: string;
    updatedAt?: string;
    comments: CommentData[];
    metadata: [ThreadMetadata] extends [never] ? Record<string, never> : ThreadMetadata;
};

declare type Options = {
    serverEndpoint: string;
};
declare type CommentsApi<ThreadMetadata extends BaseMetadata> = {
    getThreads(): Promise<ThreadData<ThreadMetadata>[]>;
    createThread(options: {
        threadId: string;
        commentId: string;
        metadata: ThreadMetadata | undefined;
        body: CommentBody;
    }): Promise<ThreadData<ThreadMetadata>>;
    editThreadMetadata(options: {
        metadata: Partial<ThreadMetadata>;
        threadId: string;
    }): Promise<ThreadData<ThreadMetadata>>;
    createComment(options: {
        threadId: string;
        commentId: string;
        body: CommentBody;
    }): Promise<CommentData>;
    editComment(options: {
        threadId: string;
        commentId: string;
        body: CommentBody;
    }): Promise<CommentData>;
    deleteComment(options: {
        threadId: string;
        commentId: string;
    }): Promise<void>;
    addReaction(options: {
        threadId: string;
        commentId: string;
        emoji: string;
    }): Promise<CommentData>;
    removeReaction(options: {
        threadId: string;
        commentId: string;
        emoji: string;
    }): Promise<CommentData>;
};
declare function createCommentsApi<ThreadMetadata extends BaseMetadata>(roomId: string, getAuthValue: () => Promise<AuthValue>, { serverEndpoint }: Options): CommentsApi<ThreadMetadata>;

declare type Callback<T> = (event: T) => void;
declare type UnsubscribeCallback = () => void;
declare type Observable<T> = {
    /**
     * Register a callback function to be called whenever the event source emits
     * an event.
     */
    subscribe(callback: Callback<T>): UnsubscribeCallback;
    /**
     * Register a one-time callback function to be called whenever the event
     * source emits an event. After the event fires, the callback is
     * auto-unsubscribed.
     */
    subscribeOnce(callback: Callback<T>): UnsubscribeCallback;
    /**
     * Returns a promise that will resolve when an event is emitted by this
     * event source. Optionally, specify a predicate that has to match. The first
     * event matching that predicate will then resolve the promise.
     */
    waitUntil(predicate?: (event: T) => boolean): Promise<T>;
};
declare type EventSource<T> = Observable<T> & {
    /**
     * Notify all subscribers about the event.
     */
    notify(event: T): void;
    /**
     * Clear all registered event listeners. None of the registered functions
     * will ever get called again. Be careful when using this API, because the
     * subscribers may not have any idea they won't be notified anymore.
     */
    clear(): void;
    /**
     * Returns the number of active subscribers.
     */
    count(): number;
    /**
     * Pauses event delivery until unpaused. Any .notify() calls made while
     * paused will get buffered into memory and emitted later.
     */
    pause(): void;
    /**
     * Emits all in-memory buffered events, and unpauses. Any .notify() calls
     * made after this will be synchronously delivered again.
     */
    unpause(): void;
    /**
     * Observable instance, which can be used to subscribe to this event source
     * in a readonly fashion. Safe to publicly expose.
     */
    observable: Observable<T>;
};
/**
 * makeEventSource allows you to generate a subscribe/notify pair of functions
 * to make subscribing easy and to get notified about events.
 *
 * The events are anonymous, so you can use it to define events, like so:
 *
 *   const event1 = makeEventSource();
 *   const event2 = makeEventSource();
 *
 *   event1.subscribe(foo);
 *   event1.subscribe(bar);
 *   event2.subscribe(qux);
 *
 *   // Unsubscription is pretty standard
 *   const unsub = event2.subscribe(foo);
 *   unsub();
 *
 *   event1.notify();  // Now foo and bar will get called
 *   event2.notify();  // Now qux will get called (but foo will not, since it's unsubscribed)
 *
 */
declare function makeEventSource<T>(): EventSource<T>;

interface IWebSocketEvent {
    type: string;
}
interface IWebSocketCloseEvent extends IWebSocketEvent {
    readonly code: number;
    readonly wasClean: boolean;
    readonly reason: string;
}
interface IWebSocketMessageEvent extends IWebSocketEvent {
    readonly data: string | Buffer | ArrayBuffer | readonly Buffer[];
}
interface IWebSocketInstance {
    readonly CONNECTING: number;
    readonly OPEN: number;
    readonly CLOSING: number;
    readonly CLOSED: number;
    readonly readyState: number;
    addEventListener(type: "close", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void;
    addEventListener(type: "message", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void;
    addEventListener(type: "open" | "error", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void;
    removeEventListener(type: "close", listener: (this: IWebSocketInstance, ev: IWebSocketCloseEvent) => unknown): void;
    removeEventListener(type: "message", listener: (this: IWebSocketInstance, ev: IWebSocketMessageEvent) => unknown): void;
    removeEventListener(type: "open" | "error", listener: (this: IWebSocketInstance, ev: IWebSocketEvent) => unknown): void;
    close(): void;
    send(data: string): void;
}
/**
 * Either the browser-based WebSocket API or Node.js' WebSocket API (from the
 * 'ws' package).
 *
 * This type defines the minimal WebSocket API that Liveblocks needs from
 * a WebSocket implementation, and is a minimal subset of the browser-based
 * WebSocket APIs and Node.js' WebSocket API so that both implementations are
 * assignable to this type.
 */
interface IWebSocket {
    new (address: string): IWebSocketInstance;
}
/**
 * The following ranges will be respected by the client:
 *
 *   40xx: client will disconnect
 *   41xx: client will reauthorize
 *   42xx: client will retry without reauthorizing (currently not used)
 *
 */
declare enum WebsocketCloseCodes {
    /** Unexpected error happened with the network/infra level. In spirit akin to HTTP 503 */
    CLOSE_ABNORMAL = 1006,
    /** Unexpected error happened. In spirit akin to HTTP 500 */
    UNEXPECTED_CONDITION = 1011,
    /** Please back off for now, but try again in a few moments */
    TRY_AGAIN_LATER = 1013,
    /** Message wasn't understood, disconnect */
    INVALID_MESSAGE_FORMAT = 4000,
    /** Server refused to allow connection. Re-authorizing won't help. Disconnect. In spirit akin to HTTP 403 */
    NOT_ALLOWED = 4001,
    /** Unused */
    MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,
    /** Unused */
    MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,
    /** Unused */
    MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,
    /** Room is full, disconnect */
    MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,
    /** The auth token is expired, reauthorize to get a fresh one. In spirit akin to HTTP 401 */
    TOKEN_EXPIRED = 4109,
    /** Disconnect immediately */
    CLOSE_WITHOUT_RETRY = 4999
}

/**
 * Old connection statuses, here for backward-compatibility reasons only.
 */
declare type LegacyConnectionStatus = "closed" | "authenticating" | "connecting" | "open" | "unavailable" | "failed";
/**
 * Returns a human-readable status indicating the current connection status of
 * a Room, as returned by `room.getStatus()`. Can be used to implement
 * a connection status badge.
 */
declare type Status = "initial" | "connecting" | "connected" | "reconnecting" | "disconnected";
/**
 * Used to report about app-level reconnection issues.
 *
 * Normal (quick) reconnects won't be reported as a "lost connection". Instead,
 * the application will only get an event if the reconnection attempts by the
 * client are taking (much) longer than usual. Definitely a situation you want
 * to inform your users about, for example, by throwing a toast message on
 * screen, or show a "trying to reconnect" banner.
 */
declare type LostConnectionEvent = "lost" | "restored" | "failed";
/**
 * Arbitrary record that will be used as the authentication "authValue". It's the
 * value that is returned by calling the authentication delegate, and will get
 * passed to the connection factory delegate. This value will be remembered by
 * the connection manager, but its value will not be interpreted, so it can be
 * any value (except null).
 */
declare type BaseAuthResult = NonNullable<Json>;
declare type Delegates<T extends BaseAuthResult> = {
    authenticate: () => Promise<T>;
    createSocket: (authValue: T) => IWebSocketInstance;
};

declare enum ClientMsgCode {
    UPDATE_PRESENCE = 100,
    BROADCAST_EVENT = 103,
    FETCH_STORAGE = 200,
    UPDATE_STORAGE = 201,
    FETCH_YDOC = 300,
    UPDATE_YDOC = 301
}
/**
 * Messages that can be sent from the client to the server.
 */
declare type ClientMsg<TPresence extends JsonObject, TRoomEvent extends Json> = BroadcastEventClientMsg<TRoomEvent> | UpdatePresenceClientMsg<TPresence> | UpdateStorageClientMsg | FetchStorageClientMsg | FetchYDocClientMsg | UpdateYDocClientMsg;
declare type BroadcastEventClientMsg<TRoomEvent extends Json> = {
    type: ClientMsgCode.BROADCAST_EVENT;
    event: TRoomEvent;
};
declare type UpdatePresenceClientMsg<TPresence extends JsonObject> = {
    readonly type: ClientMsgCode.UPDATE_PRESENCE;
    /**
     * Set this to any number to signify that this is a Full Presence™
     * update, not a patch.
     *
     * The numeric value itself no longer has specific meaning. Historically,
     * this field was intended so that clients could ignore these broadcasted
     * full presence messages, but it turned out that getting a full presence
     * "keyframe" from time to time was useful.
     *
     * So nowadays, the presence (pun intended) of this `targetActor` field
     * is a backward-compatible way of expressing that the `data` contains
     * all presence fields, and isn't a partial "patch".
     */
    readonly targetActor: number;
    readonly data: TPresence;
} | {
    readonly type: ClientMsgCode.UPDATE_PRESENCE;
    /**
     * Absence of the `targetActor` field signifies that this is a Partial
     * Presence™ "patch".
     */
    readonly targetActor?: undefined;
    readonly data: Partial<TPresence>;
};
declare type UpdateStorageClientMsg = {
    readonly type: ClientMsgCode.UPDATE_STORAGE;
    readonly ops: Op[];
};
declare type FetchStorageClientMsg = {
    readonly type: ClientMsgCode.FETCH_STORAGE;
};
declare type FetchYDocClientMsg = {
    readonly type: ClientMsgCode.FETCH_YDOC;
    readonly vector: string;
};
declare type UpdateYDocClientMsg = {
    readonly type: ClientMsgCode.UPDATE_YDOC;
    readonly update: string;
};

declare type IdTuple<T> = [id: string, value: T];
declare enum CrdtType {
    OBJECT = 0,
    LIST = 1,
    MAP = 2,
    REGISTER = 3
}
declare type SerializedCrdt = SerializedRootObject | SerializedChild;
declare type SerializedChild = SerializedObject | SerializedList | SerializedMap | SerializedRegister;
declare type SerializedRootObject = {
    readonly type: CrdtType.OBJECT;
    readonly data: JsonObject;
    readonly parentId?: never;
    readonly parentKey?: never;
};
declare type SerializedObject = {
    readonly type: CrdtType.OBJECT;
    readonly parentId: string;
    readonly parentKey: string;
    readonly data: JsonObject;
};
declare type SerializedList = {
    readonly type: CrdtType.LIST;
    readonly parentId: string;
    readonly parentKey: string;
};
declare type SerializedMap = {
    readonly type: CrdtType.MAP;
    readonly parentId: string;
    readonly parentKey: string;
};
declare type SerializedRegister = {
    readonly type: CrdtType.REGISTER;
    readonly parentId: string;
    readonly parentKey: string;
    readonly data: Json;
};
declare function isRootCrdt(crdt: SerializedCrdt): crdt is SerializedRootObject;
declare function isChildCrdt(crdt: SerializedCrdt): crdt is SerializedChild;

declare enum ServerMsgCode {
    UPDATE_PRESENCE = 100,
    USER_JOINED = 101,
    USER_LEFT = 102,
    BROADCASTED_EVENT = 103,
    ROOM_STATE = 104,
    INITIAL_STORAGE_STATE = 200,
    UPDATE_STORAGE = 201,
    REJECT_STORAGE_OP = 299,
    UPDATE_YDOC = 300,
    THREAD_CREATED = 400,
    THREAD_METADATA_UPDATED = 401,
    COMMENT_CREATED = 402,
    COMMENT_EDITED = 403,
    COMMENT_DELETED = 404
}
/**
 * Messages that can be sent from the server to the client.
 */
declare type ServerMsg<TPresence extends JsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = UpdatePresenceServerMsg<TPresence> | UserJoinServerMsg<TUserMeta> | UserLeftServerMsg | BroadcastedEventServerMsg<TRoomEvent> | RoomStateServerMsg<TUserMeta> | InitialDocumentStateServerMsg | UpdateStorageServerMsg | RejectedStorageOpServerMsg | YDocUpdateServerMsg | CommentsEventServerMsg;
declare type CommentsEventServerMsg = ThreadCreatedEvent | ThreadMetadataUpdatedEvent | CommentCreatedEvent | CommentEditedEvent | CommentDeletedEvent;
declare type ThreadCreatedEvent = {
    type: ServerMsgCode.THREAD_CREATED;
    threadId: string;
};
declare type ThreadMetadataUpdatedEvent = {
    type: ServerMsgCode.THREAD_METADATA_UPDATED;
    threadId: string;
};
declare type CommentCreatedEvent = {
    type: ServerMsgCode.COMMENT_CREATED;
    threadId: string;
    commentId: string;
};
declare type CommentEditedEvent = {
    type: ServerMsgCode.COMMENT_EDITED;
    threadId: string;
    commentId: string;
};
declare type CommentDeletedEvent = {
    type: ServerMsgCode.COMMENT_DELETED;
    threadId: string;
    commentId: string;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User updated their presence. For example, when a user moves their cursor.
 *
 * In most cases, the data payload will only include the fields from the
 * Presence that have been changed since the last announcement. However, after
 * a new user joins a room, a "full presence" will be announced so the newly
 * connected user will get each other's user full presence at least once. In
 * those cases, the `targetActor` field indicates the newly connected client,
 * so all other existing clients can ignore this broadcasted message.
 */
declare type UpdatePresenceServerMsg<TPresence extends JsonObject> = {
    readonly type: ServerMsgCode.UPDATE_PRESENCE;
    /**
     * The User whose Presence has changed.
     */
    readonly actor: number;
    /**
     * When set, signifies that this is a Full Presence™ update, not a patch.
     *
     * The numeric value itself no longer has specific meaning. Historically,
     * this field was intended so that clients could ignore these broadcasted
     * full presence messages, but it turned out that getting a full presence
     * "keyframe" from time to time was useful.
     *
     * So nowadays, the presence (pun intended) of this `targetActor` field
     * is a backward-compatible way of expressing that the `data` contains
     * all presence fields, and isn't a partial "patch".
     */
    readonly targetActor: number;
    /**
     * The partial or full Presence of a User. If the `targetActor` field is set,
     * this will be the full Presence, otherwise it only contain the fields that
     * have changed since the last broadcast.
     */
    readonly data: TPresence;
} | {
    readonly type: ServerMsgCode.UPDATE_PRESENCE;
    /**
     * The User whose Presence has changed.
     */
    readonly actor: number;
    /**
     * Not set for partial presence updates.
     */
    readonly targetActor?: undefined;
    /**
     * A partial Presence patch to apply to the User. It will only contain the
     * fields that have changed since the last broadcast.
     */
    readonly data: Partial<TPresence>;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has joined the Room.
 */
declare type UserJoinServerMsg<TUserMeta extends BaseUserMeta> = {
    readonly type: ServerMsgCode.USER_JOINED;
    readonly actor: number;
    /**
     * The id of the User that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    readonly id: TUserMeta["id"];
    /**
     * Additional user information that has been set in the authentication
     * endpoint.
     */
    readonly info: TUserMeta["info"];
    /**
     * Informs the client what (public) permissions this (other) User has.
     */
    readonly scopes: string[];
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a new User has left the Room.
 */
declare type UserLeftServerMsg = {
    readonly type: ServerMsgCode.USER_LEFT;
    readonly actor: number;
};
/**
 * Sent by the WebSocket server when the ydoc is updated or when requested based on stateVector passed.
 * Contains a base64 encoded update
 */
declare type YDocUpdateServerMsg = {
    readonly type: ServerMsgCode.UPDATE_YDOC;
    readonly update: string;
    readonly isSync: boolean;
    readonly stateVector: string | null;
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a User broadcasted an Event to everyone in the Room.
 */
declare type BroadcastedEventServerMsg<TRoomEvent extends Json> = {
    readonly type: ServerMsgCode.BROADCASTED_EVENT;
    /**
     * The User who broadcast the Event. Absent when this event is broadcast from
     * the REST API in the backend.
     */
    readonly actor: number;
    /**
     * The arbitrary payload of the Event. This can be any JSON value. Clients
     * will have to manually verify/decode this event.
     */
    readonly event: TRoomEvent;
};
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial state of the Room. The payload
 * includes a list of all other Users that already are in the Room.
 */
declare type RoomStateServerMsg<TUserMeta extends BaseUserMeta> = {
    readonly type: ServerMsgCode.ROOM_STATE;
    /**
     * Informs the client what their actor ID is going to be.
     * @since v1.2 (WS API v7)
     */
    readonly actor: number;
    /**
     * Secure nonce for the current session.
     * @since v1.2 (WS API v7)
     */
    readonly nonce: string;
    /**
     * Informs the client what permissions the current User (self) has.
     * @since v1.2 (WS API v7)
     */
    readonly scopes: string[];
    readonly users: {
        readonly [otherActor: number]: TUserMeta & {
            scopes: string[];
        };
    };
};
/**
 * Sent by the WebSocket server to a single client in response to the client
 * joining the Room, to provide the initial Storage state of the Room. The
 * payload includes the entire Storage document.
 */
declare type InitialDocumentStateServerMsg = {
    readonly type: ServerMsgCode.INITIAL_STORAGE_STATE;
    readonly items: IdTuple<SerializedCrdt>[];
};
/**
 * Sent by the WebSocket server and broadcasted to all clients to announce that
 * a change occurred in the Storage document.
 *
 * The payload of this message contains a list of Ops (aka incremental
 * mutations to make to the initially loaded document).
 */
declare type UpdateStorageServerMsg = {
    readonly type: ServerMsgCode.UPDATE_STORAGE;
    readonly ops: Op[];
};
/**
 * Sent by the WebSocket server to the client to indicate that certain opIds
 * have been received but were rejected because they caused mutations that are
 * incompatible with the Room's schema.
 */
declare type RejectedStorageOpServerMsg = {
    readonly type: ServerMsgCode.REJECT_STORAGE_OP;
    readonly opIds: string[];
    readonly reason: string;
};

/**
 * Represents a user connected in a room. Treated as immutable.
 */
declare type User<TPresence extends JsonObject, TUserMeta extends BaseUserMeta> = {
    /**
     * The connection ID of the User. It is unique and increment at every new connection.
     */
    readonly connectionId: number;
    /**
     * The ID of the User that has been set in the authentication endpoint.
     * Useful to get additional information about the connected user.
     */
    readonly id: TUserMeta["id"];
    /**
     * Additional user information that has been set in the authentication endpoint.
     */
    readonly info: TUserMeta["info"];
    /**
     * The user’s presence data.
     */
    readonly presence: TPresence;
    /**
     * @deprecated Use `!user.canWrite` instead.
     * False if the user can mutate the Room’s Storage and/or YDoc, true if they
     * can only read but not mutate it.
     */
    readonly isReadOnly: boolean;
    /**
     * True if the user can mutate the Room’s Storage and/or YDoc, false if they
     * can only read but not mutate it.
     */
    readonly canWrite: boolean;
    /**
     * True if the user can comment on a thread
     */
    readonly canComment: boolean;
};

/**
 * @deprecated Use `readonly User<TPresence, TUserMeta>[]` instead of `Others<TPresence, TUserMeta>`.
 */
declare type Others<TPresence extends JsonObject, TUserMeta extends BaseUserMeta> = readonly User<TPresence, TUserMeta>[];
declare type OthersEvent<TPresence extends JsonObject, TUserMeta extends BaseUserMeta> = {
    type: "leave";
    user: User<TPresence, TUserMeta>;
} | {
    type: "enter";
    user: User<TPresence, TUserMeta>;
} | {
    type: "update";
    user: User<TPresence, TUserMeta>;
    updates: Partial<TPresence>;
} | {
    type: "reset";
};

declare type RoomEventMessage<TPresence extends JsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = {
    /**
     * The connection ID of the client that sent the event.
     * If this message was broadcast from the server (via the REST API), then
     * this value will be -1.
     */
    connectionId: number;
    /**
     * The User (from the others list) that sent the event.
     * If this message was broadcast from the server (via the REST API), then
     * this value will be null.
     */
    user: User<TPresence, TUserMeta> | null;
    event: TRoomEvent;
};
declare type StorageStatus = "not-loaded" | "loading" | "synchronizing" | "synchronized";
interface History {
    /**
     * Undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     *
     * @example
     * room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
     * room.updatePresence({ selectedId: "yy" }, { addToHistory: true });
     * room.history.undo();
     * // room.getPresence() equals { selectedId: "xx" }
     */
    undo: () => void;
    /**
     * Redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     *
     * @example
     * room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
     * room.updatePresence({ selectedId: "yy" }, { addToHistory: true });
     * room.history.undo();
     * // room.getPresence() equals { selectedId: "xx" }
     * room.history.redo();
     * // room.getPresence() equals { selectedId: "yy" }
     */
    redo: () => void;
    /**
     * Returns whether there are any operations to undo.
     *
     * @example
     * room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
     * // room.history.canUndo() is true
     * room.history.undo();
     * // room.history.canUndo() is false
     */
    canUndo: () => boolean;
    /**
     * Returns whether there are any operations to redo.
     *
     * @example
     * room.updatePresence({ selectedId: "xx" }, { addToHistory: true });
     * room.history.undo();
     * // room.history.canRedo() is true
     * room.history.redo();
     * // room.history.canRedo() is false
     */
    canRedo: () => boolean;
    /**
     * Clears the undo and redo stacks. This operation cannot be undone ;)
     */
    clear: () => void;
    /**
     * All future modifications made on the Room will be merged together to create a single history item until resume is called.
     *
     * @example
     * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
     * room.history.pause();
     * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
     * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
     * room.history.resume();
     * room.history.undo();
     * // room.getPresence() equals { cursor: { x: 0, y: 0 } }
     */
    pause: () => void;
    /**
     * Resumes history. Modifications made on the Room are not merged into a single history item anymore.
     *
     * @example
     * room.updatePresence({ cursor: { x: 0, y: 0 } }, { addToHistory: true });
     * room.history.pause();
     * room.updatePresence({ cursor: { x: 1, y: 1 } }, { addToHistory: true });
     * room.updatePresence({ cursor: { x: 2, y: 2 } }, { addToHistory: true });
     * room.history.resume();
     * room.history.undo();
     * // room.getPresence() equals { cursor: { x: 0, y: 0 } }
     */
    resume: () => void;
}
declare type HistoryEvent = {
    canUndo: boolean;
    canRedo: boolean;
};
declare type BroadcastOptions = {
    /**
     * Whether or not event is queued if the connection is currently closed.
     *
     * ❗ We are not sure if we want to support this option in the future so it might be deprecated to be replaced by something else
     */
    shouldQueueEventIfNotReady: boolean;
};
declare type SubscribeFn<TPresence extends JsonObject, _TStorage extends LsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = {
    /**
     * Subscribe to the current user presence updates.
     *
     * @param listener the callback that is called every time the current user presence is updated with {@link Room.updatePresence}.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * room.subscribe("my-presence", (presence) => {
     *   // Do something
     * });
     */
    (type: "my-presence", listener: Callback<TPresence>): () => void;
    /**
     * Subscribe to the other users updates.
     *
     * @param listener the callback that is called when a user enters or leaves the room or when a user update its presence.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * room.subscribe("others", (others) => {
     *   // Do something
     * });
     *
     */
    (type: "others", listener: (others: readonly User<TPresence, TUserMeta>[], event: OthersEvent<TPresence, TUserMeta>) => void): () => void;
    /**
     * Subscribe to events broadcasted by {@link Room.broadcastEvent}
     *
     * @param listener the callback that is called when a user calls {@link Room.broadcastEvent}
     *
     * @returns Unsubscribe function.
     *
     * @example
     * room.subscribe("event", ({ event, connectionId }) => {
     *   // Do something
     * });
     *
     */
    (type: "event", listener: Callback<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>): () => void;
    /**
     * Subscribe to errors thrown in the room.
     *
     * @returns Unsubscribe function.
     *
     */
    (type: "error", listener: ErrorCallback): () => void;
    /**
     * @deprecated This API will be removed in a future version of Liveblocks.
     * Prefer using the newer `.subscribe('status')` API.
     *
     * We recommend making the following changes if you use these APIs:
     *
     *     OLD APIs                       NEW APIs
     *     .getConnectionState()     -->  .getStatus()
     *     .subscribe('connection')  -->  .subscribe('status')
     *
     *     OLD STATUSES         NEW STATUSES
     *     closed          -->  initial
     *     authenticating  -->  connecting
     *     connecting      -->  connecting
     *     open            -->  connected
     *     unavailable     -->  reconnecting
     *     failed          -->  disconnected
     *
     * Subscribe to legacy connection status updates.
     *
     * @returns Unsubscribe function.
     *
     */
    (type: "connection", listener: Callback<LegacyConnectionStatus>): () => void;
    /**
     * Subscribe to connection status updates. The callback will be called any
     * time the status changes.
     *
     * @returns Unsubscribe function.
     *
     */
    (type: "status", listener: Callback<Status>): () => void;
    /**
     * Subscribe to the exceptional event where reconnecting to the Liveblocks
     * servers is taking longer than usual. This typically is a sign of a client
     * that has lost internet connectivity.
     *
     * This isn't problematic (because the Liveblocks client is still trying to
     * reconnect), but it's typically a good idea to inform users about it if
     * the connection takes too long to recover.
     */
    (type: "lost-connection", listener: Callback<LostConnectionEvent>): () => void;
    /**
     * Subscribes to changes made on a Live structure. Returns an unsubscribe function.
     * In a future version, we will also expose what exactly changed in the Live structure.
     *
     * @param callback The callback this called when the Live structure changes.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject
     * const unsubscribe = room.subscribe(liveMap, (liveMap) => { });
     * unsubscribe();
     */
    <L extends LiveStructure>(liveStructure: L, callback: (node: L) => void): () => void;
    /**
     * Subscribes to changes made on a Live structure and all the nested data
     * structures. Returns an unsubscribe function. In a future version, we
     * will also expose what exactly changed in the Live structure.
     *
     * @param callback The callback this called when the Live structure, or any
     * of its nested values, changes.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * const liveMap = new LiveMap();  // Could also be LiveList or LiveObject
     * const unsubscribe = room.subscribe(liveMap, (updates) => { }, { isDeep: true });
     * unsubscribe();
     */
    <L extends LiveStructure>(liveStructure: L, callback: StorageCallback, options: {
        isDeep: true;
    }): () => void;
    /**
     * Subscribe to the current user's history changes.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * room.subscribe("history", ({ canUndo, canRedo }) => {
     *   // Do something
     * });
     */
    (type: "history", listener: Callback<HistoryEvent>): () => void;
    /**
     * Subscribe to storage status changes.
     *
     * @returns Unsubscribe function.
     *
     * @example
     * room.subscribe("storage-status", (status) => {
     *   switch(status) {
     *      case "not-loaded":
     *        break;
     *      case "loading":
     *        break;
     *      case "synchronizing":
     *        break;
     *      case "synchronized":
     *        break;
     *      default:
     *        break;
     *   }
     * });
     */
    (type: "storage-status", listener: Callback<StorageStatus>): () => void;
};
declare type Room<TPresence extends JsonObject, TStorage extends LsonObject, TUserMeta extends BaseUserMeta, TRoomEvent extends Json> = CommentsApi<any> & {
    /**
     * The id of the room.
     */
    readonly id: string;
    /**
     * @deprecated This API will be removed in a future version of Liveblocks.
     * Prefer using `.getStatus()` instead.
     *
     * We recommend making the following changes if you use these APIs:
     *
     *     OLD APIs                       NEW APIs
     *     .getConnectionState()     -->  .getStatus()
     *     .subscribe('connection')  -->  .subscribe('status')
     *
     *     OLD STATUSES         NEW STATUSES
     *     closed          -->  initial
     *     authenticating  -->  connecting
     *     connecting      -->  connecting
     *     open            -->  connected
     *     unavailable     -->  reconnecting
     *     failed          -->  disconnected
     */
    getConnectionState(): LegacyConnectionStatus;
    /**
     * Return the current connection status for this room. Can be used to display
     * a status badge for your Liveblocks connection.
     */
    getStatus(): Status;
    readonly subscribe: SubscribeFn<TPresence, TStorage, TUserMeta, TRoomEvent>;
    /**
     * Room's history contains functions that let you undo and redo operation made on by the current client on the presence and storage.
     */
    readonly history: History;
    /**
     * Gets the current user.
     * Returns null if not it is not yet connected to the room.
     *
     * @example
     * const user = room.getSelf();
     */
    getSelf(): User<TPresence, TUserMeta> | null;
    /**
     * Gets the presence of the current user.
     *
     * @example
     * const presence = room.getPresence();
     */
    getPresence(): TPresence;
    /**
     * Gets all the other users in the room.
     *
     * @example
     * const others = room.getOthers();
     */
    getOthers(): readonly User<TPresence, TUserMeta>[];
    /**
     * Updates the presence of the current user. Only pass the properties you want to update. No need to send the full presence.
     * @param patch A partial object that contains the properties you want to update.
     * @param options Optional object to configure the behavior of updatePresence.
     *
     * @example
     * room.updatePresence({ x: 0 });
     * room.updatePresence({ y: 0 });
     *
     * const presence = room.getPresence();
     * // presence is equivalent to { x: 0, y: 0 }
     */
    updatePresence(patch: Partial<TPresence>, options?: {
        /**
         * Whether or not the presence should have an impact on the undo/redo history.
         */
        addToHistory: boolean;
    }): void;
    /**
     *
     * Sends Yjs document updates to liveblocks server
     *
     * @param {string} data the doc update to send to the server, base64 encoded uint8array
     */
    updateYDoc(data: string): void;
    /**
     * Sends a request for the current document from liveblocks server
     */
    fetchYDoc(stateVector: string): void;
    /**
     * Broadcasts an event to other users in the room. Event broadcasted to the room can be listened with {@link Room.subscribe}("event").
     * @param {any} event the event to broadcast. Should be serializable to JSON
     *
     * @example
     * // On client A
     * room.broadcastEvent({ type: "EMOJI", emoji: "🔥" });
     *
     * // On client B
     * room.subscribe("event", ({ event }) => {
     *   if(event.type === "EMOJI") {
     *     // Do something
     *   }
     * });
     */
    broadcastEvent(event: TRoomEvent, options?: BroadcastOptions): void;
    /**
     * Get the room's storage asynchronously.
     * The storage's root is a {@link LiveObject}.
     *
     * @example
     * const { root } = await room.getStorage();
     */
    getStorage(): Promise<{
        root: LiveObject<TStorage>;
    }>;
    /**
     * Get the room's storage synchronously.
     * The storage's root is a {@link LiveObject}.
     *
     * @example
     * const root = room.getStorageSnapshot();
     */
    getStorageSnapshot(): LiveObject<TStorage> | null;
    readonly events: {
        /** @deprecated Prefer `status` instead. */
        readonly connection: Observable<LegacyConnectionStatus>;
        readonly status: Observable<Status>;
        readonly lostConnection: Observable<LostConnectionEvent>;
        readonly customEvent: Observable<RoomEventMessage<TPresence, TUserMeta, TRoomEvent>>;
        readonly self: Observable<User<TPresence, TUserMeta>>;
        readonly myPresence: Observable<TPresence>;
        readonly others: Observable<{
            others: readonly User<TPresence, TUserMeta>[];
            event: OthersEvent<TPresence, TUserMeta>;
        }>;
        readonly error: Observable<Error>;
        readonly storage: Observable<StorageUpdate[]>;
        readonly history: Observable<HistoryEvent>;
        /**
         * Subscribe to the storage loaded event. Will fire any time a full Storage
         * copy is downloaded. (This happens after the initial connect, and on
         * every reconnect.)
         */
        readonly storageDidLoad: Observable<void>;
        readonly storageStatus: Observable<StorageStatus>;
        readonly ydoc: Observable<YDocUpdateServerMsg | UpdateYDocClientMsg>;
        readonly comments: Observable<CommentsEventServerMsg>;
    };
    /**
     * Batches modifications made during the given function.
     * All the modifications are sent to other clients in a single message.
     * All the subscribers are called only after the batch is over.
     * All the modifications are merged in a single history item (undo/redo).
     *
     * @example
     * const { root } = await room.getStorage();
     * room.batch(() => {
     *   root.set("x", 0);
     *   room.updatePresence({ cursor: { x: 100, y: 100 }});
     * });
     */
    batch<T>(fn: () => T): T;
    /**
     * Get the storage status.
     *
     * - `not-loaded`: Initial state when entering the room.
     * - `loading`: Once the storage has been requested via room.getStorage().
     * - `synchronizing`: When some local updates have not been acknowledged by Liveblocks servers.
     * - `synchronized`: Storage is in sync with Liveblocks servers.
     */
    getStorageStatus(): StorageStatus;
    /**
     * Reconnect the room to the Liveblocks server by re-establishing a fresh
     * connection. If the room is not connected yet, initiate it.
     */
    reconnect(): void;
};
declare type Polyfills = {
    atob?: (data: string) => string;
    fetch?: typeof fetch;
    WebSocket?: IWebSocket;
};
declare type RoomInitializers<TPresence extends JsonObject, TStorage extends LsonObject> = Resolve<{
    /**
     * The initial Presence to use and announce when you enter the Room. The
     * Presence is available on all users in the Room (me & others).
     */
    initialPresence: TPresence | ((roomId: string) => TPresence);
    /**
     * The initial Storage to use when entering a new Room.
     */
    initialStorage?: TStorage | ((roomId: string) => TStorage);
    /**
     * Whether or not the room connects to Liveblock servers. Default is true.
     *
     * Usually set to false when the client is used from the server to not call
     * the authentication endpoint or connect via WebSocket.
     */
    shouldInitiallyConnect?: boolean;
}>;

declare type EnterOptions<TPresence extends JsonObject, TStorage extends LsonObject> = Resolve<RoomInitializers<TPresence, TStorage> & {
    /**
     * Only necessary when you’re using Liveblocks with React v17 or lower.
     *
     * If so, pass in a reference to `ReactDOM.unstable_batchedUpdates` here.
     * This will allow Liveblocks to circumvent the so-called "zombie child
     * problem". To learn more, see
     * https://liveblocks.io/docs/guides/troubleshooting#stale-props-zombie-child
     */
    unstable_batchedUpdates?: (cb: () => void) => void;
}>;
declare type Client = {
    /**
     * Gets a room. Returns null if {@link Client.enter} has not been called previously.
     *
     * @param roomId The id of the room
     */
    getRoom<TPresence extends JsonObject, TStorage extends LsonObject = LsonObject, TUserMeta extends BaseUserMeta = BaseUserMeta, TRoomEvent extends Json = never>(roomId: string): Room<TPresence, TStorage, TUserMeta, TRoomEvent> | null;
    /**
     * Enters a room and returns it.
     * @param roomId The id of the room
     * @param options Optional. You can provide initializers for the Presence or Storage when entering the Room.
     */
    enter<TPresence extends JsonObject, TStorage extends LsonObject = LsonObject, TUserMeta extends BaseUserMeta = BaseUserMeta, TRoomEvent extends Json = never>(roomId: string, options: EnterOptions<TPresence, TStorage>): Room<TPresence, TStorage, TUserMeta, TRoomEvent>;
    /**
     * Leaves a room.
     * @param roomId The id of the room
     */
    leave(roomId: string): void;
};
declare type AuthEndpoint = string | ((room: string) => Promise<CustomAuthenticationResult>);
/**
 * The authentication endpoint that is called to ensure that the current user has access to a room.
 * Can be an url or a callback if you need to add additional headers.
 */
declare type ClientOptions = {
    throttle?: number;
    lostConnectionTimeout?: number;
    polyfills?: Polyfills;
    unstable_fallbackToHTTP?: boolean;
    /**
     * @deprecated Use `polyfills: { fetch: ... }` instead.
     * This option will be removed in a future release.
     */
    fetchPolyfill?: Polyfills["fetch"];
    /**
     * @deprecated Use `polyfills: { WebSocket: ... }` instead.
     * This option will be removed in a future release.
     */
    WebSocketPolyfill?: Polyfills["WebSocket"];
} & ({
    publicApiKey: string;
    authEndpoint?: never;
} | {
    publicApiKey?: never;
    authEndpoint: AuthEndpoint;
});
/**
 * Create a client that will be responsible to communicate with liveblocks servers.
 *
 * @example
 * const client = createClient({
 *   authEndpoint: "/api/auth"
 * });
 *
 * // It's also possible to use a function to call your authentication endpoint.
 * // Useful to add additional headers or use an API wrapper (like Firebase functions)
 * const client = createClient({
 *   authEndpoint: async (room) => {
 *     const response = await fetch("/api/auth", {
 *       method: "POST",
 *       headers: {
 *          Authentication: "token",
 *          "Content-Type": "application/json"
 *       },
 *       body: JSON.stringify({ room })
 *     });
 *
 *     return await response.json(); // should be: { token: "..." }
 *   }
 * });
 */
declare function createClient(options: ClientOptions): Client;

/**
 * Lookup table for nodes (= SerializedCrdt values) by their IDs.
 */
declare type NodeMap = Map<string, // Node ID
SerializedCrdt>;
/**
 * Reverse lookup table for all child nodes (= list of SerializedCrdt values)
 * by their parent node's IDs.
 */
declare type ParentToChildNodeMap = Map<string, // Parent's node ID
IdTuple<SerializedChild>[]>;

declare function isLiveNode(value: unknown): value is LiveNode;

declare function lsonToJson(value: Lson): Json;
declare function patchLiveObjectKey<O extends LsonObject, K extends keyof O, V extends Json>(liveObject: LiveObject<O>, key: K, prev?: V, next?: V): void;
declare function legacy_patchImmutableObject<S extends JsonObject>(state: S, updates: StorageUpdate[]): S;

/**
 * Helper function that can be used to implement exhaustive switch statements
 * with TypeScript. Example usage:
 *
 *    type Fruit = "🍎" | "🍌";
 *
 *    switch (fruit) {
 *      case "🍎":
 *      case "🍌":
 *        return doSomething();
 *
 *      default:
 *        return assertNever(fruit, "Unknown fruit");
 *    }
 *
 * If now the Fruit union is extended (i.e. add "🍒"), TypeScript will catch
 * this *statically*, rather than at runtime, and force you to handle the
 * 🍒 case.
 */
declare function assertNever(_value: never, errmsg: string): never;
/**
 * Asserts that a certain condition holds. If it does not hold, will throw
 * a runtime error in dev mode.
 *
 * In production, nothing is asserted and this acts as a no-op.
 */
declare function assert(condition: boolean, errmsg: string): asserts condition;
/**
 * Asserts that a given value is non-nullable. This is similar to TypeScript's
 * `!` operator, but will throw an error at runtime (dev-mode only) indicating
 * an incorrect assumption.
 *
 * Instead of:
 *
 *     foo!.bar
 *
 * Use:
 *
 *     nn(foo).bar
 *
 */
declare function nn<T>(value: T, errmsg?: string): NonNullable<T>;

declare type AsyncFunction<T, A extends any[] = any[]> = (...args: A) => Promise<T>;
declare type AsyncCacheOptions<T, E> = {
    isStateEqual?: (a: AsyncState<T, E>, b: AsyncState<T, E>) => boolean;
};
declare type AsyncStateInitial = {
    readonly isLoading: false;
    readonly data?: never;
    readonly error?: never;
};
declare type AsyncStateLoading<T> = {
    readonly isLoading: true;
    readonly data?: T;
    readonly error?: never;
};
declare type AsyncStateSuccess<T> = {
    readonly isLoading: false;
    readonly data: T;
    readonly error?: never;
};
declare type AsyncStateError<T, E> = {
    readonly isLoading: false;
    readonly data?: T;
    readonly error: E;
};
declare type AsyncState<T, E> = AsyncStateInitial | AsyncStateLoading<T> | AsyncStateSuccess<T> | AsyncStateError<T, E>;
declare type AsyncStateResolved<T, E> = AsyncStateSuccess<T> | AsyncStateError<T, E>;
declare type AsyncCacheItem<T, E> = Observable<AsyncState<T, E>> & {
    setAsyncFunction(asyncFunction: AsyncFunction<T, [string]>): void;
    get(): Promise<AsyncStateResolved<T, E>>;
    getState(): AsyncState<T, E>;
    revalidate(): Promise<AsyncStateResolved<T, E>>;
};
declare type AsyncCache<T, E> = {
    /**
     * @private
     *
     * Creates a key in the cache.
     *
     * @param key The key to create.
     * @param asyncFunction Override the cache's function for this key.
     */
    create(key: string, asyncFunction?: AsyncFunction<T, [string]>): AsyncCacheItem<T, E>;
    /**
     * Returns a promise which resolves with the state of the key.
     *
     * @param key The key to get.
     */
    get(key: string): Promise<AsyncStateResolved<T, E>>;
    /**
     * Returns the current state of the key synchronously.
     *
     * @param key The key to get the state of.
     */
    getState(key: string): AsyncState<T, E> | undefined;
    /**
     * Revalidates the key.
     *
     * @param key The key to revalidate.
     */
    revalidate(key: string): Promise<AsyncStateResolved<T, E>>;
    /**
     * Subscribes to the key's changes.
     *
     * @param key The key to subscribe to.
     * @param callback The function invoked on every change.
     */
    subscribe(key: string, callback: Callback<AsyncState<T, E>>): UnsubscribeCallback;
    /**
     * Subscribes to the key's changes once.
     *
     * @param key The key to subscribe to.
     * @param callback The function invoked on every change.
     */
    subscribeOnce(key: string, callback: Callback<AsyncState<T, E>>): UnsubscribeCallback;
    /**
     * Returns whether a key already exists in the cache.
     *
     * @param key The key to look for.
     */
    has(key: string): boolean;
    /**
     * Clears all keys.
     */
    clear(): void;
};
declare function createAsyncCache<T, E>(asyncFunction: AsyncFunction<T, [string]>, options?: AsyncCacheOptions<T, E>): AsyncCache<T, E>;

/**
 * Displays a deprecation warning in the dev console. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecate(message: string, key?: string): void;
/**
 * Conditionally displays a deprecation warning in the dev
 * console if the first argument is truthy. Only in dev mode, and
 * only once per message/key. In production, this is a no-op.
 */
declare function deprecateIf(condition: unknown, message: string, key?: string): void;
/**
 * Throws a deprecation error in the dev console.
 *
 * Only triggers in dev mode. In production, this is a no-op.
 */
declare function throwUsageError(message: string): void;
/**
 * Conditionally throws a usage error in the dev console if the first argument
 * is truthy. Use this to "escalate" usage patterns that in previous versions
 * we already warned about with deprecation warnings.
 *
 * Only has effect in dev mode. In production, this is a no-op.
 */
declare function errorIf(condition: unknown, message: string): void;

declare const warn: (message: string, ...args: readonly unknown[]) => void;
declare const error: (message: string, ...args: readonly unknown[]) => void;
declare const warnWithTitle: (title: string, message: string, ...args: readonly unknown[]) => void;
declare const errorWithTitle: (title: string, message: string, ...args: readonly unknown[]) => void;

declare const fancyConsole_error: typeof error;
declare const fancyConsole_errorWithTitle: typeof errorWithTitle;
declare const fancyConsole_warn: typeof warn;
declare const fancyConsole_warnWithTitle: typeof warnWithTitle;
declare namespace fancyConsole {
  export {
    fancyConsole_error as error,
    fancyConsole_errorWithTitle as errorWithTitle,
    fancyConsole_warn as warn,
    fancyConsole_warnWithTitle as warnWithTitle,
  };
}

/**
 * Freezes the given argument, but only in development builds. In production
 * builds, this is a no-op for performance reasons.
 */
declare const freeze: typeof Object.freeze;

declare type Poller = {
    start(interval: number): void;
    restart(interval: number): void;
    pause(): void;
    resume(): void;
    stop(): void;
};
declare function makePoller(callback: () => Promise<void> | void): Poller;

declare const brand: unique symbol;
declare type Brand<T, TBrand extends string> = T & {
    [brand]: TBrand;
};
declare function isPlainObject(blob: unknown): blob is {
    [key: string]: unknown;
};
/**
 * Alternative to JSON.parse() that will not throw in production. If the passed
 * string cannot be parsed, this will return `undefined`.
 */
declare function tryParseJson(rawMessage: string): Json | undefined;
/**
 * Decode base64 string.
 */
declare function b64decode(b64value: string): string;
/**
 * Returns whatever the given promise returns, but will be rejected with
 * a "Timed out" error if the given promise does not return or reject within
 * the given timeout period (in milliseconds).
 */
declare function withTimeout<T>(promise: Promise<T>, millis: number, errmsg?: string): Promise<T>;

/**
 * Positions, aka the Pos type, are efficient encodings of "positions" in
 * a list, using the following printable subset of the ASCII alphabet:
 *
 *    !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
 *   ^                                                                                             ^
 *   Lowest digit                                                                      Highest digit
 *
 * Each Pos is a sequence of characters from the above alphabet, conceptually
 * codifying a floating point number 0 < n < 1. For example, the string "31007"
 * would be used to represent the number 0.31007, except that this
 * representation uses base 96.
 *
 *   0 ≃ ' '  (lowest digit)
 *   1 ≃ '!'
 *   2 ≃ '"'
 *   ...
 *   9 ≃ '~'  (highest digit)
 *
 * So think:
 *   '!'    ≃ 0.1
 *   '"'    ≃ 0.2
 *   '!"~'  ≃ 0.129
 *
 * Three rules:
 * - All "characters" in the string should be valid digits (from the above
 *   alphabet)
 * - The value 0.0 is not a valid Pos value
 * - A Pos cannot have trailing "zeroes"
 *
 * This representation has the following benefits:
 *
 * 1. It's always possible to get a number that lies before, after, or between
 *    two arbitrary Pos values.
 * 2. Pos values can be compared using normal string comparison.
 *
 * Some examples:
 * - '!'  < '"'   (like how .1  < .2)
 * - '!'  < '~'   (like how .1  < .9)
 * - '!!' < '!~'  (like how .11 < .19)
 * - '~!' < '~~'  (like how .91 < .99)
 * - '~'  < '~!'  (like how .9  < .91)
 * - '!!' < '!O'  (like how .1  < .5)
 * - '!O' < '!~'  (like how .5  < .9)
 *
 */

/**
 * A valid/verified "position" string. These values are used as "parentKey"s by
 * LiveList children, and define their relative ordering.
 */
declare type Pos = Brand<string, "Pos">;
/**
 * Given two positions, returns the position value that lies in the middle.
 * When given only a high bound, computes the canonical position "before" it.
 * When given only a low bound, computes the canonical position "after" it.
 * When given no bounds at all, returns the "first" canonical position.
 */
declare function makePosition(x?: Pos, y?: Pos): Pos;
/**
 * Checks that a str is a valid Pos, and converts it to the nearest valid one
 * if not.
 */
declare function asPos(str: string): Pos;

/**
 * Shallowly compares two given values.
 *
 * - Two simple values are considered equal if they're strictly equal
 * - Two arrays are considered equal if their members are strictly equal
 * - Two objects are considered equal if their values are strictly equal
 *
 * Testing goes one level deep.
 */
declare function shallow(a: unknown, b: unknown): boolean;

declare type JsonTreeNode = {
    readonly type: "Json";
    readonly id: string;
    readonly key: string;
    readonly payload: Json;
};
declare type LiveTreeNode<TName extends `Live${string}` = `Live${string}`> = {
    readonly type: TName;
    readonly id: string;
    readonly key: string;
    readonly payload: LsonTreeNode[];
};
declare type LsonTreeNode = LiveTreeNode | JsonTreeNode;
declare type UserTreeNode = {
    readonly type: "User";
    readonly id: string;
    readonly key: string;
    readonly payload: {
        readonly connectionId: number;
        readonly id?: string;
        readonly info?: Json;
        readonly presence: JsonObject;
        readonly isReadOnly: boolean;
    };
};
declare type CustomEventTreeNode = {
    readonly type: "CustomEvent";
    readonly id: string;
    readonly key: string;
    readonly connectionId: number;
    readonly payload: Json;
};
declare type TreeNode = LsonTreeNode | UserTreeNode | CustomEventTreeNode;

type DevToolsTreeNode_CustomEventTreeNode = CustomEventTreeNode;
type DevToolsTreeNode_JsonTreeNode = JsonTreeNode;
type DevToolsTreeNode_LiveTreeNode<TName extends `Live${string}` = `Live${string}`> = LiveTreeNode<TName>;
type DevToolsTreeNode_LsonTreeNode = LsonTreeNode;
type DevToolsTreeNode_TreeNode = TreeNode;
type DevToolsTreeNode_UserTreeNode = UserTreeNode;
declare namespace DevToolsTreeNode {
  export {
    DevToolsTreeNode_CustomEventTreeNode as CustomEventTreeNode,
    DevToolsTreeNode_JsonTreeNode as JsonTreeNode,
    DevToolsTreeNode_LiveTreeNode as LiveTreeNode,
    DevToolsTreeNode_LsonTreeNode as LsonTreeNode,
    DevToolsTreeNode_TreeNode as TreeNode,
    DevToolsTreeNode_UserTreeNode as UserTreeNode,
  };
}

/**
 * Definition of all messages the Panel can send to the Client.
 */
declare type PanelToClientMessage = 
/**
 * Initial message from the panel to the client, used for two purposes.
 * 1. First, it’s eavesdropped by the background script, which uses this
 *    message to register a "port", which sets up a channel for two-way
 *    communication between panel and client for the remainder of the time.
 * 2. It signifies to the client that the devpanel is listening.
 */
{
    msg: "connect";
}
/**
 * Expresses to the client that the devtool is interested in
 * receiving the "sync stream" for the room. The sync stream
 * that follows is an initial "full sync", followed by many
 * "partial" syncs, happening for every update.
 */
 | {
    msg: "room::subscribe";
    roomId: string;
}
/**
 * Expresses to the client that the devtool no longer is
 * interested in the "sync stream" for a room, for example,
 * because the devtools panel is closed, or if it switched to
 * a different room.
 */
 | {
    msg: "room::unsubscribe";
    roomId: string;
};
/**
 * Definition of all messages the Client can send to the Panel.
 */
declare type ClientToPanelMessage = 
/**
 * Initial message sent by the client to test if a dev panel is listening.
 * This is necessary in cases where the dev panel is already opened and
 * listened, before the client is loaded. If the panel receives this message,
 * it will replay its initial "connect" message, which triggers the loading
 * of the two-way connection.
 */
{
    msg: "wake-up-devtools";
}
/**
 * Sent when a new room is available for the dev panel to track and watch.
 * Sent by the client as soon as the room is attempted to be entered. This
 * happens _before_ the actual connection to the room server is established,
 * meaning the room is visible to the devtools even while it is connecting.
 */
 | {
    msg: "room::available";
    roomId: string;
    clientVersion: string;
}
/**
 * Sent when a room is left and the client loses track of the room instance.
 */
 | {
    msg: "room::unavailable";
    roomId: string;
}
/**
 * Sent initially, to synchronize the entire current state of the room.
 */
 | {
    msg: "room::sync::full";
    roomId: string;
    status: Status;
    storage: readonly LsonTreeNode[] | null;
    me: UserTreeNode | null;
    others: readonly UserTreeNode[];
}
/**
 * Sent whenever something about the internals of a room changes.
 */
 | {
    msg: "room::sync::partial";
    roomId: string;
    status?: Status;
    storage?: readonly LsonTreeNode[];
    me?: UserTreeNode;
    others?: readonly UserTreeNode[];
}
/**
 * Sent whenever an user room event is emitted in the room.
 */
 | {
    msg: "room::events::custom-event";
    roomId: string;
    event: CustomEventTreeNode;
}
/**
 * Sent whenever the ydoc is updated
 */
 | {
    msg: "room::sync::ydoc";
    roomId: string;
    update: YDocUpdateServerMsg | UpdateYDocClientMsg;
};
declare type FullPanelToClientMessage = PanelToClientMessage & {
    source: "liveblocks-devtools-panel";
    tabId: number;
};
declare type FullClientToPanelMessage = ClientToPanelMessage & {
    source: "liveblocks-devtools-client";
};

type protocol_ClientToPanelMessage = ClientToPanelMessage;
type protocol_FullClientToPanelMessage = FullClientToPanelMessage;
type protocol_FullPanelToClientMessage = FullPanelToClientMessage;
type protocol_PanelToClientMessage = PanelToClientMessage;
declare namespace protocol {
  export {
    protocol_ClientToPanelMessage as ClientToPanelMessage,
    protocol_FullClientToPanelMessage as FullClientToPanelMessage,
    protocol_FullPanelToClientMessage as FullPanelToClientMessage,
    protocol_PanelToClientMessage as PanelToClientMessage,
  };
}

/**
 * Helper type to help users adopt to Lson types from interface definitions.
 * You should only use this to wrap interfaces you don't control. For more
 * information, see
 * https://liveblocks.io/docs/guides/limits#lson-constraint-and-interfaces
 */
declare type EnsureJson<T> = [
    unknown
] extends [T] ? T : T extends (...args: unknown[]) => unknown ? T : {
    [K in keyof T]: EnsureJson<T[K]>;
};

export { AckOp, AsyncCache, AsyncState, AsyncStateError, AsyncStateInitial, AsyncStateLoading, AsyncStateResolved, AsyncStateSuccess, BaseAuthResult, BaseMetadata, BaseUserMeta, BroadcastEventClientMsg, BroadcastOptions, BroadcastedEventServerMsg, Client, ClientMsg, ClientMsgCode, CommentBody, CommentBodyElement, CommentBodyLink, CommentBodyMention, CommentBodyParagraph, CommentBodyText, CommentData, CommentReaction, CommentsApi, CrdtType, CreateChildOp, CreateListOp, CreateMapOp, CreateObjectOp, CreateOp, CreateRegisterOp, CreateRootObjectOp, CustomAuthenticationResult, Delegates, DeleteCrdtOp, DeleteObjectKeyOp, DevToolsTreeNode as DevTools, protocol as DevToolsMsg, EnsureJson, EventSource, FetchStorageClientMsg, FetchYDocClientMsg, History, IWebSocket, IWebSocketCloseEvent, IWebSocketEvent, IWebSocketInstance, IWebSocketMessageEvent, IdTuple, Immutable, InitialDocumentStateServerMsg, Json, JsonArray, JsonObject, JsonScalar, LegacyConnectionStatus, LiveList, LiveListUpdate, LiveMap, LiveMapUpdate, LiveNode, LiveObject, LiveObjectUpdate, LiveStructure, LostConnectionEvent, Lson, LsonObject, NodeMap, Op, OpCode, Others, ParentToChildNodeMap, PlainLson, PlainLsonFields, PlainLsonList, PlainLsonMap, PlainLsonObject, RejectedStorageOpServerMsg, Resolve, Room, RoomEventMessage, RoomInitializers, RoomStateServerMsg, SerializedChild, SerializedCrdt, SerializedList, SerializedMap, SerializedObject, SerializedRegister, SerializedRootObject, ServerMsg, ServerMsgCode, SetParentKeyOp, Status, StorageStatus, StorageUpdate, ThreadData, ToImmutable, ToJson, UnsubscribeCallback, UpdateObjectOp, UpdatePresenceClientMsg, UpdatePresenceServerMsg, UpdateStorageClientMsg, UpdateStorageServerMsg, UpdateYDocClientMsg, User, UserJoinServerMsg, UserLeftServerMsg, WebsocketCloseCodes, YDocUpdateServerMsg, asPos, assert, assertNever, b64decode, fancyConsole as console, createAsyncCache, createClient, createCommentsApi, deprecate, deprecateIf, detectDupes, errorIf, freeze, isChildCrdt, isJsonArray, isJsonObject, isJsonScalar, isLiveNode, isPlainObject, isRootCrdt, legacy_patchImmutableObject, lsonToJson, makeEventSource, makePoller, makePosition, nn, patchLiveObjectKey, shallow, throwUsageError, toPlainLson, tryParseJson, withTimeout };
