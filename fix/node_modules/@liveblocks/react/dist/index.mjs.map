{"version":3,"sources":["../src/index.ts","../src/version.ts","../src/ClientSideSuspense.tsx","../src/factory.tsx","../src/comments/CommentsRoom.ts","../src/comments/errors.ts","../src/comments/lib/use-debounce.ts","../src/lib/stable-stringify.ts","../src/lib/use-async-cache.ts","../src/lib/use-initial.ts","../src/lib/use-rerender.ts"],"sourcesContent":["import { detectDupes } from \"@liveblocks/core\";\n\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport { ClientSideSuspense } from \"./ClientSideSuspense\";\nexport { createRoomContext, useRoomContextBundle } from \"./factory\";\nexport type {\n  MutationContext,\n  ResolveMentionSuggestionsOptions,\n  ResolveUserOptions,\n} from \"./types\";\n\n// Re-exports from @liveblocks/client, for convenience\nexport type { Json, JsonObject } from \"@liveblocks/client\";\nexport { shallow } from \"@liveblocks/client\";\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/react\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n","import type { ReactElement, ReactNode } from \"react\";\nimport * as React from \"react\";\n\ntype Props = {\n  fallback: NonNullable<ReactNode> | null;\n  children: () => ReactNode | undefined;\n};\n\n/**\n * Almost like a normal <Suspense> component, except that for server-side\n * renders, the fallback will be used.\n *\n * The child props will have to be provided in a function, i.e. change:\n *\n *   <Suspense fallback={<Loading />}>\n *     <MyRealComponent a={1} />\n *   </Suspense>\n *\n * To:\n *\n *   <ClientSideSuspense fallback={<Loading />}>\n *     {() => <MyRealComponent a={1} />}\n *   </ClientSideSuspense>\n *\n */\nexport function ClientSideSuspense(props: Props): ReactElement {\n  const [mounted, setMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    // Effects are never executed on the server side. The point of this is to\n    // delay the flipping of this boolean until after hydration has happened.\n    setMounted(true);\n  }, []);\n\n  return (\n    <React.Suspense fallback={props.fallback}>\n      {mounted ? props.children() : props.fallback}\n    </React.Suspense>\n  );\n}\n","import type {\n  BaseUserMeta,\n  BroadcastOptions,\n  Client,\n  History,\n  Json,\n  JsonObject,\n  LiveObject,\n  LostConnectionEvent,\n  LsonObject,\n  Room,\n  Status,\n  User,\n} from \"@liveblocks/client\";\nimport { shallow } from \"@liveblocks/client\";\nimport type {\n  AsyncCache,\n  BaseMetadata,\n  CommentData,\n  RoomEventMessage,\n  ToImmutable,\n} from \"@liveblocks/core\";\nimport {\n  createAsyncCache,\n  deprecateIf,\n  errorIf,\n  isLiveNode,\n  makeEventSource,\n} from \"@liveblocks/core\";\nimport * as React from \"react\";\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\n\nimport type {\n  CommentReactionOptions,\n  CommentsRoom,\n  CreateCommentOptions,\n  CreateThreadOptions,\n  DeleteCommentOptions,\n  EditCommentOptions,\n  EditThreadMetadataOptions,\n  ThreadsState,\n} from \"./comments/CommentsRoom\";\nimport { createCommentsRoom } from \"./comments/CommentsRoom\";\nimport type { CommentsApiError } from \"./comments/errors\";\nimport { useDebounce } from \"./comments/lib/use-debounce\";\nimport { stableStringify } from \"./lib/stable-stringify\";\nimport { useAsyncCache } from \"./lib/use-async-cache\";\nimport { useInitial } from \"./lib/use-initial\";\nimport { useRerender } from \"./lib/use-rerender\";\nimport type {\n  InternalRoomContextBundle,\n  MutationContext,\n  OmitFirstArg,\n  ResolveMentionSuggestionsOptions,\n  ResolveUserOptions,\n  RoomContextBundle,\n  RoomProviderProps,\n  UserState,\n  UserStateSuccess,\n} from \"./types\";\n\nconst noop = () => {};\nconst identity: <T>(x: T) => T = (x) => x;\n\nconst missing_unstable_batchedUpdates = (\n  reactVersion: number,\n  roomId: string\n) =>\n  `We noticed you’re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you’re ready to upgrade to React 18:\n\n    import { unstable_batchedUpdates } from \"react-dom\";  // or \"react-native\"\n\n    <RoomProvider id=${JSON.stringify(\n      roomId\n    )} ... unstable_batchedUpdates={unstable_batchedUpdates}>\n      ...\n    </RoomProvider>\n\nWhy? Please see https://liveblocks.io/docs/guides/troubleshooting#stale-props-zombie-child for more information`;\n\nconst superfluous_unstable_batchedUpdates =\n  \"You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.\";\n\nfunction useSyncExternalStore<Snapshot>(\n  s: (onStoreChange: () => void) => () => void,\n  gs: () => Snapshot,\n  gss: undefined | null | (() => Snapshot)\n): Snapshot {\n  return useSyncExternalStoreWithSelector(s, gs, gss, identity);\n}\n\n// Don't try to inline this. This function itself must be a stable reference.\nfunction getEmptyOthers() {\n  return [];\n}\n\nfunction makeMutationContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject,\n  TUserMeta extends BaseUserMeta,\n  TRoomEvent extends Json,\n>(\n  room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>\n): MutationContext<TPresence, TStorage, TUserMeta> {\n  const errmsg =\n    \"This mutation cannot be used until connected to the Liveblocks room\";\n\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(errmsg);\n      }\n      return mutableRoot;\n    },\n\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(errmsg);\n      }\n      return self;\n    },\n\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(errmsg);\n      }\n      return others;\n    },\n\n    setMyPresence: room.updatePresence,\n  };\n}\n\ntype Options<TUserMeta extends BaseUserMeta> = {\n  /**\n   * @beta\n   *\n   * An asynchronous function that returns user info from a user ID.\n   */\n  resolveUser?: (\n    options: ResolveUserOptions\n  ) => Promise<TUserMeta[\"info\"] | undefined>;\n\n  /**\n   * @beta\n   *\n   * An asynchronous function that returns a list of user IDs matching a string.\n   */\n  resolveMentionSuggestions?: (\n    options: ResolveMentionSuggestionsOptions\n  ) => Promise<string[]>;\n\n  /**\n   * @internal Internal endpoint\n   */\n  serverEndpoint?: string;\n};\n\nlet hasWarnedIfNoResolveUser = false;\n\nfunction warnIfNoResolveUser(usersCache?: AsyncCache<unknown, unknown>) {\n  if (\n    !hasWarnedIfNoResolveUser &&\n    !usersCache &&\n    process.env.NODE_ENV !== \"production\"\n  ) {\n    console.warn(\n      \"Set the resolveUser option in createRoomContext to specify user info.\"\n    );\n    hasWarnedIfNoResolveUser = true;\n  }\n}\n\n// TODO: Remove after beta\nlet hasWarnedAboutCommentsBeta = false;\nfunction warnIfBetaCommentsHook() {\n  if (!hasWarnedAboutCommentsBeta && process.env.NODE_ENV !== \"production\") {\n    console.warn(\n      \"Comments is currently in private beta. Learn more at https://liveblocks.io/docs/products/comments.\"\n    );\n    hasWarnedAboutCommentsBeta = true;\n  }\n}\n\nconst ContextBundle = React.createContext<InternalRoomContextBundle<\n  JsonObject,\n  LsonObject,\n  BaseUserMeta,\n  never,\n  BaseMetadata\n> | null>(null);\n\n/**\n * @private\n *\n * This is an internal API, use `createRoomContext` instead.\n */\nexport function useRoomContextBundle() {\n  const bundle = React.useContext(ContextBundle);\n  if (bundle === null) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return bundle;\n}\n\nexport function createRoomContext<\n  TPresence extends JsonObject,\n  TStorage extends LsonObject = LsonObject,\n  TUserMeta extends BaseUserMeta = BaseUserMeta,\n  TRoomEvent extends Json = never,\n  TThreadMetadata extends BaseMetadata = never,\n>(\n  client: Client,\n  options?: Options<TUserMeta>\n): RoomContextBundle<\n  TPresence,\n  TStorage,\n  TUserMeta,\n  TRoomEvent,\n  TThreadMetadata\n> {\n  const RoomContext = React.createContext<Room<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent\n  > | null>(null);\n\n  function RoomProvider(props: RoomProviderProps<TPresence, TStorage>) {\n    const {\n      id: roomId,\n      initialPresence,\n      initialStorage,\n      unstable_batchedUpdates,\n      shouldInitiallyConnect,\n    } = props;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!roomId) {\n        throw new Error(\n          \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n        );\n      }\n\n      if (typeof roomId !== \"string\") {\n        throw new Error(\"RoomProvider id property should be a string.\");\n      }\n\n      const majorReactVersion = parseInt(React.version) || 1;\n      const oldReactVersion = majorReactVersion < 18;\n      errorIf(\n        oldReactVersion && props.unstable_batchedUpdates === undefined,\n        missing_unstable_batchedUpdates(majorReactVersion, roomId)\n      );\n      deprecateIf(\n        !oldReactVersion && props.unstable_batchedUpdates !== undefined,\n        superfluous_unstable_batchedUpdates\n      );\n    }\n\n    // Note: We'll hold on to the initial value given here, and ignore any\n    // changes to this argument in subsequent renders\n    const frozen = useInitial({\n      initialPresence,\n      initialStorage,\n      unstable_batchedUpdates,\n      shouldInitiallyConnect:\n        shouldInitiallyConnect === undefined\n          ? typeof window !== \"undefined\"\n          : shouldInitiallyConnect,\n    });\n\n    const [room, setRoom] = React.useState<\n      Room<TPresence, TStorage, TUserMeta, TRoomEvent>\n    >(() =>\n      client.enter(roomId, {\n        initialPresence: frozen.initialPresence,\n        initialStorage: frozen.initialStorage,\n        shouldInitiallyConnect: frozen.shouldInitiallyConnect,\n        unstable_batchedUpdates: frozen.unstable_batchedUpdates,\n      })\n    );\n\n    React.useEffect(() => {\n      const room = client.enter<TPresence, TStorage, TUserMeta, TRoomEvent>(\n        roomId,\n        {\n          initialPresence: frozen.initialPresence,\n          initialStorage: frozen.initialStorage,\n          shouldInitiallyConnect: frozen.shouldInitiallyConnect,\n          unstable_batchedUpdates: frozen.unstable_batchedUpdates,\n        }\n      );\n\n      setRoom(room);\n\n      return () => {\n        const commentsRoom = commentsRooms.get(room);\n        if (commentsRoom) {\n          commentsRooms.delete(room);\n        }\n        client.leave(roomId);\n      };\n    }, [roomId, frozen]);\n\n    return (\n      <RoomContext.Provider value={room}>\n        <ContextBundle.Provider\n          value={\n            internalBundle as unknown as InternalRoomContextBundle<\n              JsonObject,\n              LsonObject,\n              BaseUserMeta,\n              never,\n              BaseMetadata\n            >\n          }\n        >\n          {props.children}\n        </ContextBundle.Provider>\n      </RoomContext.Provider>\n    );\n  }\n\n  function connectionIdSelector(\n    others: readonly User<TPresence, TUserMeta>[]\n  ): number[] {\n    return others.map((user) => user.connectionId);\n  }\n\n  function useRoom(): Room<TPresence, TStorage, TUserMeta, TRoomEvent> {\n    const room = React.useContext(RoomContext);\n    if (room === null) {\n      throw new Error(\"RoomProvider is missing from the React tree.\");\n    }\n    return room;\n  }\n\n  function useStatus(): Status {\n    const room = useRoom();\n    const subscribe = room.events.status.subscribe;\n    const getSnapshot = room.getStatus;\n    return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  }\n\n  function useMyPresence(): [\n    TPresence,\n    (patch: Partial<TPresence>, options?: { addToHistory: boolean }) => void,\n  ] {\n    const room = useRoom();\n    const subscribe = room.events.myPresence.subscribe;\n    const getSnapshot = room.getPresence;\n    const presence = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n    const setPresence = room.updatePresence;\n    return [presence, setPresence];\n  }\n\n  function useUpdateMyPresence(): (\n    patch: Partial<TPresence>,\n    options?: { addToHistory: boolean }\n  ) => void {\n    return useRoom().updatePresence;\n  }\n\n  function useOthers(): readonly User<TPresence, TUserMeta>[];\n  function useOthers<T>(\n    selector: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useOthers<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    const room = useRoom();\n    const subscribe = room.events.others.subscribe;\n    const getSnapshot = room.getOthers;\n    const getServerSnapshot = getEmptyOthers;\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector ??\n        (identity as (others: readonly User<TPresence, TUserMeta>[]) => T),\n      isEqual\n    );\n  }\n\n  function useOthersConnectionIds(): readonly number[] {\n    return useOthers(connectionIdSelector, shallow);\n  }\n\n  function useOthersMapped<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) =>\n        others.map(\n          (other) => [other.connectionId, itemSelector(other)] as const\n        ),\n      [itemSelector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (\n        a: ReadonlyArray<readonly [connectionId: number, data: T]>,\n        b: ReadonlyArray<readonly [connectionId: number, data: T]>\n      ): boolean => {\n        const eq = itemIsEqual ?? Object.is;\n        return (\n          a.length === b.length &&\n          a.every((atuple, index) => {\n            const btuple = b[index];\n            return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n          })\n        );\n      },\n      [itemIsEqual]\n    );\n\n    return useOthers(wrappedSelector, wrappedIsEqual);\n  }\n\n  const NOT_FOUND = Symbol();\n\n  type NotFound = typeof NOT_FOUND;\n\n  function useOther<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    const wrappedSelector = React.useCallback(\n      (others: readonly User<TPresence, TUserMeta>[]) => {\n        // TODO: Make this O(1) instead of O(n)?\n        const other = others.find(\n          (other) => other.connectionId === connectionId\n        );\n        return other !== undefined ? selector(other) : NOT_FOUND;\n      },\n      [connectionId, selector]\n    );\n\n    const wrappedIsEqual = React.useCallback(\n      (prev: T | NotFound, curr: T | NotFound): boolean => {\n        if (prev === NOT_FOUND || curr === NOT_FOUND) {\n          return prev === curr;\n        }\n\n        const eq = isEqual ?? Object.is;\n        return eq(prev, curr);\n      },\n      [isEqual]\n    );\n\n    const other = useOthers(wrappedSelector, wrappedIsEqual);\n    if (other === NOT_FOUND) {\n      throw new Error(\n        `No such other user with connection id ${connectionId} exists`\n      );\n    }\n\n    return other;\n  }\n\n  function useBroadcastEvent(): (\n    event: TRoomEvent,\n    options?: BroadcastOptions\n  ) => void {\n    const room = useRoom();\n\n    return React.useCallback(\n      (\n        event: TRoomEvent,\n        options: BroadcastOptions = { shouldQueueEventIfNotReady: false }\n      ) => {\n        room.broadcastEvent(event, options);\n      },\n      [room]\n    );\n  }\n\n  function useLostConnectionListener(\n    callback: (event: LostConnectionEvent) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = React.useRef(callback);\n\n    React.useEffect(() => {\n      savedCallback.current = callback;\n    });\n\n    React.useEffect(\n      () =>\n        room.events.lostConnection.subscribe((event: LostConnectionEvent) =>\n          savedCallback.current(event)\n        ),\n      [room]\n    );\n  }\n\n  function useErrorListener(callback: (err: Error) => void): void {\n    const room = useRoom();\n    const savedCallback = React.useRef(callback);\n\n    React.useEffect(() => {\n      savedCallback.current = callback;\n    });\n\n    React.useEffect(\n      () => room.events.error.subscribe((e: Error) => savedCallback.current(e)),\n      [room]\n    );\n  }\n\n  function useEventListener(\n    callback: (data: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>) => void\n  ): void {\n    const room = useRoom();\n    const savedCallback = React.useRef(callback);\n\n    React.useEffect(() => {\n      savedCallback.current = callback;\n    });\n\n    React.useEffect(() => {\n      const listener = (\n        eventData: RoomEventMessage<TPresence, TUserMeta, TRoomEvent>\n      ) => {\n        savedCallback.current(eventData);\n      };\n\n      return room.events.customEvent.subscribe(listener);\n    }, [room]);\n  }\n\n  function useSelf(): User<TPresence, TUserMeta> | null;\n  function useSelf<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null;\n  function useSelf<T>(\n    maybeSelector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | User<TPresence, TUserMeta> | null {\n    type Snapshot = User<TPresence, TUserMeta> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const subscribe = room.events.self.subscribe;\n    const getSnapshot: () => Snapshot = room.getSelf;\n\n    const selector =\n      maybeSelector ?? (identity as (me: User<TPresence, TUserMeta>) => T);\n    const wrappedSelector = React.useCallback(\n      (me: Snapshot): Selection => (me !== null ? selector(me) : null),\n      [selector]\n    );\n\n    const getServerSnapshot = React.useCallback((): Snapshot => null, []);\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function useMutableStorageRoot(): LiveObject<TStorage> | null {\n    type Snapshot = LiveObject<TStorage> | null;\n    const room = useRoom();\n    const subscribe = room.events.storageDidLoad.subscribeOnce;\n    const getSnapshot = room.getStorageSnapshot;\n    const getServerSnapshot = React.useCallback((): Snapshot => null, []);\n    return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  }\n\n  // NOTE: This API exists for backward compatible reasons\n  function useStorageRoot(): [root: LiveObject<TStorage> | null] {\n    return [useMutableStorageRoot()];\n  }\n\n  function useHistory(): History {\n    return useRoom().history;\n  }\n\n  function useUndo(): () => void {\n    return useHistory().undo;\n  }\n\n  function useRedo(): () => void {\n    return useHistory().redo;\n  }\n\n  function useCanUndo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canUndo = room.history.canUndo;\n    return useSyncExternalStore(subscribe, canUndo, canUndo);\n  }\n\n  function useCanRedo(): boolean {\n    const room = useRoom();\n    const subscribe = room.events.history.subscribe;\n    const canRedo = room.history.canRedo;\n    return useSyncExternalStore(subscribe, canRedo, canRedo);\n  }\n\n  function useBatch<T>(): (callback: () => T) => T {\n    return useRoom().batch;\n  }\n\n  function useLegacyKey<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] | null {\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n    const rerender = useRerender();\n\n    React.useEffect(() => {\n      if (rootOrNull === null) {\n        return;\n      }\n      const root = rootOrNull;\n\n      let unsubCurr: (() => void) | undefined;\n      let curr = root.get(key);\n\n      function subscribeToCurr() {\n        unsubCurr = isLiveNode(curr)\n          ? room.subscribe(curr, rerender)\n          : undefined;\n      }\n\n      function onRootChange() {\n        const newValue = root.get(key);\n        if (newValue !== curr) {\n          unsubCurr?.();\n          curr = newValue;\n          subscribeToCurr();\n          rerender();\n        }\n      }\n\n      subscribeToCurr();\n      rerender();\n\n      const unsubscribeRoot = room.subscribe(root, onRootChange);\n      return () => {\n        unsubscribeRoot();\n        unsubCurr?.();\n      };\n    }, [rootOrNull, room, key, rerender]);\n\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      return rootOrNull.get(key);\n    }\n  }\n\n  function useStorage<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T | null, curr: T | null) => boolean\n  ): T | null {\n    type Snapshot = ToImmutable<TStorage> | null;\n    type Selection = T | null;\n\n    const room = useRoom();\n    const rootOrNull = useMutableStorageRoot();\n\n    const wrappedSelector = React.useCallback(\n      (rootOrNull: Snapshot): Selection =>\n        rootOrNull !== null ? selector(rootOrNull) : null,\n      [selector]\n    );\n\n    const subscribe = React.useCallback(\n      (onStoreChange: () => void) =>\n        rootOrNull !== null\n          ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true })\n          : noop,\n      [room, rootOrNull]\n    );\n\n    const getSnapshot = React.useCallback((): Snapshot => {\n      if (rootOrNull === null) {\n        return null;\n      } else {\n        const root = rootOrNull;\n        const imm = root.toImmutable();\n        return imm;\n      }\n    }, [rootOrNull]);\n\n    const getServerSnapshot = React.useCallback((): Snapshot => null, []);\n\n    return useSyncExternalStoreWithSelector(\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      wrappedSelector,\n      isEqual\n    );\n  }\n\n  function ensureNotServerSide(): void {\n    // Error early if suspense is used in a server-side context\n    if (typeof window === \"undefined\") {\n      throw new Error(\n        \"You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr\"\n      );\n    }\n  }\n\n  function useSuspendUntilStorageLoaded(): void {\n    const room = useRoom();\n    if (room.getStorageSnapshot() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until this\n    // promise resolves (aka until storage has loaded). After that, it will\n    // render this component tree again.\n    throw new Promise<void>((res) => {\n      room.events.storageDidLoad.subscribeOnce(() => res());\n    });\n  }\n\n  function useSuspendUntilPresenceLoaded(): void {\n    const room = useRoom();\n    if (room.getSelf() !== null) {\n      return;\n    }\n\n    ensureNotServerSide();\n\n    // Throw a _promise_. Suspense will suspend the component tree until this\n    // promise resolves (aka until storage has loaded). After that, it will\n    // render this component tree again.\n    throw new Promise<void>((res) => {\n      room.events.status.subscribeOnce(() => res());\n    });\n  }\n\n  function useMutation<\n    F extends (\n      context: MutationContext<TPresence, TStorage, TUserMeta>,\n      ...args: any[]\n    ) => any,\n  >(callback: F, deps: readonly unknown[]): OmitFirstArg<F> {\n    const room = useRoom();\n    return React.useMemo(\n      () => {\n        return ((...args) =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          room.batch(() =>\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n              ...args\n            )\n          )) as OmitFirstArg<F>;\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [room, ...deps]\n    );\n  }\n\n  function useStorageSuspense<T>(\n    selector: (root: ToImmutable<TStorage>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilStorageLoaded();\n    return useStorage(\n      selector,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T;\n  }\n\n  function useSelfSuspense(): User<TPresence, TUserMeta>;\n  function useSelfSuspense<T>(\n    selector: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T;\n  function useSelfSuspense<T>(\n    selector?: (me: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | User<TPresence, TUserMeta> {\n    useSuspendUntilPresenceLoaded();\n    return useSelf(\n      selector as (me: User<TPresence, TUserMeta>) => T,\n      isEqual as (prev: T | null, curr: T | null) => boolean\n    ) as T | User<TPresence, TUserMeta>;\n  }\n\n  function useOthersSuspense<T>(\n    selector?: (others: readonly User<TPresence, TUserMeta>[]) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T | readonly User<TPresence, TUserMeta>[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthers(\n      selector as (others: readonly User<TPresence, TUserMeta>[]) => T,\n      isEqual as (prev: T, curr: T) => boolean\n    ) as T | readonly User<TPresence, TUserMeta>[];\n  }\n\n  function useOthersConnectionIdsSuspense(): readonly number[] {\n    useSuspendUntilPresenceLoaded();\n    return useOthersConnectionIds();\n  }\n\n  function useOthersMappedSuspense<T>(\n    itemSelector: (other: User<TPresence, TUserMeta>) => T,\n    itemIsEqual?: (prev: T, curr: T) => boolean\n  ): ReadonlyArray<readonly [connectionId: number, data: T]> {\n    useSuspendUntilPresenceLoaded();\n    return useOthersMapped(itemSelector, itemIsEqual);\n  }\n\n  function useOtherSuspense<T>(\n    connectionId: number,\n    selector: (other: User<TPresence, TUserMeta>) => T,\n    isEqual?: (prev: T, curr: T) => boolean\n  ): T {\n    useSuspendUntilPresenceLoaded();\n    return useOther(connectionId, selector, isEqual);\n  }\n\n  function useLegacyKeySuspense<TKey extends Extract<keyof TStorage, string>>(\n    key: TKey\n  ): TStorage[TKey] {\n    useSuspendUntilStorageLoaded();\n    return useLegacyKey(key) as TStorage[TKey];\n  }\n\n  const commentsErrorEventSource =\n    makeEventSource<CommentsApiError<TThreadMetadata>>();\n  const commentsRooms = new Map<\n    Room<TPresence, TStorage, TUserMeta, TRoomEvent>,\n    CommentsRoom<TThreadMetadata>\n  >();\n\n  function getCommentsRoom(\n    room: Room<TPresence, TStorage, TUserMeta, TRoomEvent>\n  ) {\n    let commentsRoom = commentsRooms.get(room);\n    if (commentsRoom === undefined) {\n      commentsRoom = createCommentsRoom(room, commentsErrorEventSource);\n      commentsRooms.set(room, commentsRoom);\n    }\n    return commentsRoom;\n  }\n\n  function useThreads(): ThreadsState<TThreadMetadata> {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return getCommentsRoom(room).useThreads();\n  }\n\n  function useThreadsSuspense() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return getCommentsRoom(room).useThreadsSuspense();\n  }\n\n  function useCreateThread() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: CreateThreadOptions<TThreadMetadata>) =>\n        getCommentsRoom(room).createThread(options),\n      [room]\n    );\n  }\n\n  function useEditThreadMetadata() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: EditThreadMetadataOptions<TThreadMetadata>) =>\n        getCommentsRoom(room).editThreadMetadata(options),\n      [room]\n    );\n  }\n\n  function useAddReaction() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: CommentReactionOptions) =>\n        getCommentsRoom(room).addReaction(options),\n      [room]\n    );\n  }\n\n  function useRemoveReaction() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: CommentReactionOptions) =>\n        getCommentsRoom(room).removeReaction(options),\n      [room]\n    );\n  }\n\n  function useCreateComment(): (options: CreateCommentOptions) => CommentData {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: CreateCommentOptions) =>\n        getCommentsRoom(room).createComment(options),\n      [room]\n    );\n  }\n\n  function useEditComment(): (options: EditCommentOptions) => void {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: EditCommentOptions) =>\n        getCommentsRoom(room).editComment(options),\n      [room]\n    );\n  }\n\n  function useDeleteComment() {\n    const room = useRoom();\n\n    React.useEffect(() => {\n      warnIfBetaCommentsHook();\n    }, []);\n\n    return React.useCallback(\n      (options: DeleteCommentOptions) =>\n        getCommentsRoom(room).deleteComment(options),\n      [room]\n    );\n  }\n\n  const { resolveUser, resolveMentionSuggestions } = options ?? {};\n\n  const usersCache = resolveUser\n    ? createAsyncCache((stringifiedOptions: string) => {\n        return resolveUser(\n          JSON.parse(stringifiedOptions) as ResolveUserOptions\n        );\n      })\n    : undefined;\n\n  function useUser(userId: string) {\n    const resolverKey = React.useMemo(\n      () => stableStringify({ userId }),\n      [userId]\n    );\n    const state = useAsyncCache(usersCache, resolverKey);\n\n    React.useEffect(() => warnIfNoResolveUser(usersCache), []);\n\n    if (state.isLoading) {\n      return {\n        isLoading: true,\n      } as UserState<TUserMeta[\"info\"]>;\n    } else {\n      return {\n        user: state.data,\n        error: state.error,\n        isLoading: false,\n      } as UserState<TUserMeta[\"info\"]>;\n    }\n  }\n\n  function useUserSuspense(userId: string) {\n    const resolverKey = React.useMemo(\n      () => stableStringify({ userId }),\n      [userId]\n    );\n    const state = useAsyncCache(usersCache, resolverKey, {\n      suspense: true,\n    });\n\n    React.useEffect(() => warnIfNoResolveUser(usersCache), []);\n\n    return {\n      user: state.data,\n      isLoading: false,\n    } as UserStateSuccess<TUserMeta[\"info\"]>;\n  }\n\n  const mentionSuggestionsCache = createAsyncCache<string[], unknown>(\n    resolveMentionSuggestions\n      ? (stringifiedOptions: string) => {\n          return resolveMentionSuggestions(\n            JSON.parse(stringifiedOptions) as ResolveMentionSuggestionsOptions\n          );\n        }\n      : () => Promise.resolve([])\n  );\n\n  function useMentionSuggestions(search?: string) {\n    const room = useRoom();\n    const debouncedSearch = useDebounce(search, 500);\n    const resolverKey = React.useMemo(\n      () =>\n        debouncedSearch !== undefined\n          ? stableStringify({ text: debouncedSearch, roomId: room.id })\n          : null,\n      [debouncedSearch, room.id]\n    );\n    const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {\n      keepPreviousDataWhileLoading: true,\n    });\n\n    return data;\n  }\n\n  const bundle: RoomContextBundle<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent,\n    TThreadMetadata\n  > = {\n    RoomContext,\n    RoomProvider,\n\n    useRoom,\n    useStatus,\n\n    useBatch,\n    useBroadcastEvent,\n    useLostConnectionListener,\n    useErrorListener,\n    useEventListener,\n\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n\n    // These are just aliases. The passed-in key will define their return values.\n    useList: useLegacyKey,\n    useMap: useLegacyKey,\n    useObject: useLegacyKey,\n\n    useStorageRoot,\n    useStorage,\n\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n\n    useMutation,\n\n    useThreads,\n    useUser,\n\n    useCreateThread,\n    useEditThreadMetadata,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n\n    suspense: {\n      RoomContext,\n      RoomProvider,\n\n      useRoom,\n      useStatus,\n\n      useBatch,\n      useBroadcastEvent,\n      useLostConnectionListener,\n      useErrorListener,\n      useEventListener,\n\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n\n      // Legacy hooks\n      useList: useLegacyKeySuspense,\n      useMap: useLegacyKeySuspense,\n      useObject: useLegacyKeySuspense,\n\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n\n      useMutation,\n\n      useThreads: useThreadsSuspense,\n      useUser: useUserSuspense,\n\n      useCreateThread,\n      useEditThreadMetadata,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n    },\n  };\n\n  const internalBundle: InternalRoomContextBundle<\n    TPresence,\n    TStorage,\n    TUserMeta,\n    TRoomEvent,\n    TThreadMetadata\n  > = {\n    ...bundle,\n    hasResolveMentionSuggestions: resolveMentionSuggestions !== undefined,\n    useMentionSuggestions,\n  };\n\n  return bundle;\n}\n","import type {\n  BaseMetadata,\n  BaseUserMeta,\n  CommentBody,\n  CommentData,\n  EventSource,\n  Json,\n  JsonObject,\n  LsonObject,\n  Room,\n  ThreadData,\n} from \"@liveblocks/core\";\nimport { makeEventSource } from \"@liveblocks/core\";\nimport { nanoid } from \"nanoid\";\nimport { useEffect } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nimport {\n  AddReactionError,\n  type CommentsApiError,\n  CreateCommentError,\n  CreateThreadError,\n  DeleteCommentError,\n  EditCommentError,\n  EditThreadMetadataError,\n  RemoveReactionError,\n} from \"./errors\";\n\nconst POLLING_INTERVAL_REALTIME = 30000;\nconst POLLING_INTERVAL = 5000;\n\nconst MAX_ERROR_RETRY_COUNT = 5;\nconst ERROR_RETRY_INTERVAL = 5000;\n\nconst THREAD_ID_PREFIX = \"th\";\nconst COMMENT_ID_PREFIX = \"cm\";\nconst DEDUPING_INTERVAL = 1000;\n\nexport type CommentsRoom<TThreadMetadata extends BaseMetadata> = {\n  useThreads(): ThreadsState<TThreadMetadata>;\n  useThreadsSuspense(): ThreadsStateSuccess<TThreadMetadata>;\n  createThread(\n    options: CreateThreadOptions<TThreadMetadata>\n  ): ThreadData<TThreadMetadata>;\n  editThreadMetadata(options: EditThreadMetadataOptions<TThreadMetadata>): void;\n  createComment(options: CreateCommentOptions): CommentData;\n  addReaction(options: CommentReactionOptions): void;\n  removeReaction(options: CommentReactionOptions): void;\n  editComment(options: EditCommentOptions): void;\n  deleteComment(options: DeleteCommentOptions): void;\n};\n\nexport type CreateThreadOptions<TMetadata extends BaseMetadata> = [\n  TMetadata,\n] extends [never]\n  ? {\n      body: CommentBody;\n    }\n  : { body: CommentBody; metadata: TMetadata };\n\nexport type EditThreadMetadataOptions<TMetadata extends BaseMetadata> = [\n  TMetadata,\n] extends [never]\n  ? {\n      threadId: string;\n    }\n  : { threadId: string; metadata: Partial<TMetadata> };\n\nexport type CreateCommentOptions = {\n  threadId: string;\n  body: CommentBody;\n};\n\nexport type EditCommentOptions = {\n  threadId: string;\n  commentId: string;\n  body: CommentBody;\n};\n\nexport type DeleteCommentOptions = {\n  threadId: string;\n  commentId: string;\n};\n\nexport type CommentReactionOptions = {\n  threadId: string;\n  commentId: string;\n  emoji: string;\n};\n\nexport type ThreadsStateLoading = {\n  isLoading: true;\n  threads?: never;\n  error?: never;\n};\n\nexport type ThreadsStateError = {\n  isLoading: false;\n  threads?: never;\n  error: Error;\n};\n\nexport type ThreadsStateSuccess<TThreadMetadata extends BaseMetadata> = {\n  isLoading: false;\n  threads: ThreadData<TThreadMetadata>[];\n  error?: never;\n};\n\nexport type ThreadsState<TThreadMetadata extends BaseMetadata> =\n  | ThreadsStateLoading\n  | ThreadsStateError\n  | ThreadsStateSuccess<TThreadMetadata>;\n\ntype ThreadsRequestInfo<TThreadMetadata extends BaseMetadata> = {\n  fetcher: Promise<ThreadData<TThreadMetadata>[]>;\n  timestamp: number;\n};\n\ntype MutationInfo = {\n  startTime: number;\n  endTime: number;\n};\n\nfunction createOptimisticId(prefix: string) {\n  return `${prefix}_${nanoid()}`;\n}\n\nfunction createThreadsManager<TThreadMetadata extends BaseMetadata>() {\n  let cache: ThreadsState<TThreadMetadata> | undefined; // Stores the current cache state (threads)\n  let request: ThreadsRequestInfo<TThreadMetadata> | undefined; // Stores the currently active revalidation request\n  let mutation: MutationInfo | undefined; // Stores the start and end time of the currently active mutation\n\n  const eventSource = makeEventSource<\n    ThreadsState<TThreadMetadata> | undefined\n  >();\n\n  return {\n    get cache() {\n      return cache;\n    },\n\n    set cache(value: ThreadsState<TThreadMetadata> | undefined) {\n      cache = value;\n      eventSource.notify(cache);\n    },\n\n    get request() {\n      return request;\n    },\n\n    set request(value: ThreadsRequestInfo<TThreadMetadata> | undefined) {\n      request = value;\n    },\n\n    get mutation() {\n      return mutation;\n    },\n\n    set mutation(value: MutationInfo | undefined) {\n      mutation = value;\n    },\n\n    subscribe(\n      callback: (state: ThreadsState<TThreadMetadata> | undefined) => void\n    ) {\n      return eventSource.subscribe(callback);\n    },\n  };\n}\n\n/**\n * This implementation is inspired by the `swr` library.\n * Additional modifications were made to adapt it to our specific needs.\n *\n * Original `swr` library can be found at [SWR GitHub repository](https://github.com/vercel/swr)\n */\nexport function createCommentsRoom<TThreadMetadata extends BaseMetadata>(\n  room: Room<JsonObject, LsonObject, BaseUserMeta, Json>,\n  errorEventSource: EventSource<CommentsApiError<TThreadMetadata>>\n): CommentsRoom<TThreadMetadata> {\n  const manager = createThreadsManager<TThreadMetadata>();\n\n  let timestamp = 0;\n\n  let commentsEventRefCount = 0; // Reference count for the number of components with a subscription (via the `subscribe` function)\n  let commentsEventDisposer: (() => void) | undefined; // Disposer function for the `comments` event listener\n\n  async function mutate(\n    data: Promise<any>,\n    options: {\n      optimisticData: ThreadData<TThreadMetadata>[];\n    }\n  ) {\n    const beforeMutationTimestamp = ++timestamp;\n    manager.mutation = {\n      startTime: beforeMutationTimestamp,\n      endTime: 0,\n    };\n\n    const currentCache = manager.cache;\n\n    // Update the cache with the optimistic data\n    manager.cache = {\n      isLoading: false,\n      threads: options.optimisticData,\n    };\n\n    try {\n      await data;\n\n      // If there was a newer mutation while this mutation was in flight, we return early and don't trigger a revalidation (since the mutation request is outdated)\n      const activeMutation = manager.mutation;\n      if (\n        activeMutation &&\n        beforeMutationTimestamp !== activeMutation.startTime\n      ) {\n        return;\n      }\n    } catch (err) {\n      // If the mutation request fails, revert the optimistic update and throw the error\n      manager.cache = currentCache;\n      throw err;\n    }\n\n    // Mark the mutation as completed by setting the end time to the current timestamp\n    manager.mutation = {\n      startTime: beforeMutationTimestamp,\n      endTime: ++timestamp,\n    };\n\n    // Deleting the concurrent request markers so new requests will not be deduped.\n    manager.request = undefined;\n    void revalidateCache(false);\n  }\n\n  /**\n   * Revalidates the cache (threads) and optionally dedupes the request.\n   * @param shouldDedupe - If true, the request will be deduped\n   * @param retryCount - The number of times the request has been retried (used for exponential backoff)\n   */\n  async function revalidateCache(shouldDedupe: boolean, retryCount = 0) {\n    let startAt: number;\n\n    // A new request should be started if there is no ongoing request OR if `shouldDedupe` is false\n    const shouldStartRequest = !manager.request || !shouldDedupe;\n\n    function deleteActiveRequest() {\n      const activeRequest = manager.request;\n      if (!activeRequest) return;\n      if (activeRequest.timestamp !== startAt) return;\n\n      manager.request = undefined;\n    }\n\n    // Uses the exponential backoff algorithm to retry the request on error.\n    function handleError() {\n      const timeout =\n        ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) *\n        ERROR_RETRY_INTERVAL;\n\n      if (retryCount > MAX_ERROR_RETRY_COUNT) return;\n\n      setTimeout(() => {\n        void revalidateCache(true, retryCount + 1);\n      }, timeout);\n    }\n\n    try {\n      if (shouldStartRequest) {\n        const currentCache = manager.cache;\n        if (!currentCache) manager.cache = { isLoading: true };\n\n        manager.request = {\n          fetcher: room.getThreads(),\n          timestamp: ++timestamp,\n        };\n      }\n\n      const activeRequest = manager.request;\n      if (!activeRequest) return;\n\n      const newData = await activeRequest.fetcher;\n      startAt = activeRequest.timestamp;\n\n      if (shouldStartRequest) {\n        setTimeout(deleteActiveRequest, DEDUPING_INTERVAL);\n      }\n\n      // If there was a newer revalidation request (or if the current request was removed due to a mutation), while this request was in flight, we return early and don't update the cache (since the revalidation request is outdated)\n      if (!manager.request || manager.request.timestamp !== startAt) return;\n\n      // If there is an active mutation, we ignore the revalidation result as it is outdated (and because the mutation will trigger a revalidation)\n      const activeMutation = manager.mutation;\n      if (\n        activeMutation &&\n        (activeMutation.startTime > startAt ||\n          activeMutation.endTime > startAt ||\n          activeMutation.endTime === 0)\n      ) {\n        return;\n      }\n\n      manager.cache = {\n        isLoading: false,\n        threads: newData,\n      };\n    } catch (err) {\n      if (shouldStartRequest) handleError();\n\n      deleteActiveRequest();\n\n      manager.cache = {\n        isLoading: false,\n        error: err as Error,\n      };\n    }\n  }\n\n  function editThreadMetadata(\n    options: EditThreadMetadataOptions<TThreadMetadata>\n  ) {\n    const threadId = options.threadId;\n    const metadata: Partial<TThreadMetadata> =\n      \"metadata\" in options ? options.metadata : {};\n    const threads = getThreads();\n\n    const optimisticData = threads.map((thread) =>\n      thread.id === threadId\n        ? {\n            ...thread,\n            metadata: {\n              ...thread.metadata,\n              ...metadata,\n            },\n          }\n        : thread\n    );\n\n    mutate(room.editThreadMetadata({ metadata, threadId }), {\n      optimisticData,\n    }).catch((err: Error) => {\n      errorEventSource.notify(\n        new EditThreadMetadataError(err, {\n          roomId: room.id,\n          threadId,\n          metadata,\n        })\n      );\n    });\n  }\n\n  function createThread(\n    options: CreateThreadOptions<TThreadMetadata>\n  ): ThreadData<TThreadMetadata> {\n    const body = options.body;\n    const metadata: TThreadMetadata =\n      \"metadata\" in options ? options.metadata : ({} as TThreadMetadata);\n    const threads = getThreads();\n\n    const threadId = createOptimisticId(THREAD_ID_PREFIX);\n    const commentId = createOptimisticId(COMMENT_ID_PREFIX);\n    const now = new Date().toISOString();\n\n    const newThread = {\n      id: threadId,\n      type: \"thread\",\n      createdAt: now,\n      roomId: room.id,\n      metadata,\n      comments: [\n        {\n          id: commentId,\n          createdAt: now,\n          type: \"comment\",\n          userId: getCurrentUserId(),\n          body,\n        },\n      ],\n    } as ThreadData<TThreadMetadata>;\n\n    mutate(room.createThread({ threadId, commentId, body, metadata }), {\n      optimisticData: [...threads, newThread],\n    }).catch((er: Error) =>\n      errorEventSource.notify(\n        new CreateThreadError(er, {\n          roomId: room.id,\n          threadId,\n          commentId,\n          body,\n          metadata,\n        })\n      )\n    );\n\n    return newThread;\n  }\n\n  function createComment({\n    threadId,\n    body,\n  }: CreateCommentOptions): CommentData {\n    const threads = getThreads();\n\n    const commentId = createOptimisticId(COMMENT_ID_PREFIX);\n    const now = new Date().toISOString();\n\n    const comment: CommentData = {\n      id: commentId,\n      threadId,\n      roomId: room.id,\n      type: \"comment\",\n      createdAt: now,\n      userId: getCurrentUserId(),\n      body,\n      reactions: [],\n    };\n\n    const optimisticData = threads.map((thread) =>\n      thread.id === threadId\n        ? {\n            ...thread,\n            comments: [...thread.comments, comment],\n          }\n        : thread\n    );\n\n    mutate(room.createComment({ threadId, commentId, body }), {\n      optimisticData,\n    }).catch((er: Error) =>\n      errorEventSource.notify(\n        new CreateCommentError(er, {\n          roomId: room.id,\n          threadId,\n          commentId,\n          body,\n        })\n      )\n    );\n\n    return comment;\n  }\n\n  function editComment({ threadId, commentId, body }: EditCommentOptions) {\n    const threads = getThreads();\n    const now = new Date().toISOString();\n\n    const optimisticData = threads.map((thread) =>\n      thread.id === threadId\n        ? {\n            ...thread,\n            comments: thread.comments.map((comment) =>\n              comment.id === commentId\n                ? ({\n                    ...comment,\n                    editedAt: now,\n                    body,\n                  } as CommentData)\n                : comment\n            ),\n          }\n        : thread\n    );\n\n    mutate(room.editComment({ threadId, commentId, body }), {\n      optimisticData,\n    }).catch((er: Error) =>\n      errorEventSource.notify(\n        new EditCommentError(er, {\n          roomId: room.id,\n          threadId,\n          commentId,\n          body,\n        })\n      )\n    );\n  }\n\n  function deleteComment({ threadId, commentId }: DeleteCommentOptions): void {\n    const threads = getThreads();\n    const now = new Date().toISOString();\n\n    const newThreads: ThreadData<TThreadMetadata>[] = [];\n\n    for (const thread of threads) {\n      if (thread.id === threadId) {\n        const newThread: ThreadData<TThreadMetadata> = {\n          ...thread,\n          comments: thread.comments.map((comment) =>\n            comment.id === commentId\n              ? {\n                  ...comment,\n                  deletedAt: now,\n                  body: undefined,\n                }\n              : comment\n          ),\n        };\n\n        if (\n          newThread.comments.some((comment) => comment.deletedAt === undefined)\n        ) {\n          newThreads.push(newThread);\n        }\n      } else {\n        newThreads.push(thread);\n      }\n    }\n\n    mutate(room.deleteComment({ threadId, commentId }), {\n      optimisticData: newThreads,\n    }).catch((er: Error) =>\n      errorEventSource.notify(\n        new DeleteCommentError(er, {\n          roomId: room.id,\n          threadId,\n          commentId,\n        })\n      )\n    );\n  }\n\n  function getCurrentUserId() {\n    const self = room.getSelf();\n    if (self === null || self.id === undefined) {\n      return \"anonymous\";\n    } else {\n      return self.id;\n    }\n  }\n\n  function getThreads(): ThreadData<TThreadMetadata>[] {\n    const threads = manager.cache;\n    if (!threads || threads.isLoading || threads.error) {\n      throw new Error(\n        \"Cannot update threads or comments before they are loaded.\"\n      );\n    }\n    return threads.threads;\n  }\n\n  /**\n   * Subscribes to the `comments` event and returns a function that can be used to unsubscribe.\n   * Ensures that there is only one subscription to the `comments` event despite multiple calls to the `subscribe` function (via the `useThreads` hook).\n   * This is so that revalidation is only triggered once when the `comments` event is fired.\n   *\n   * @returns An unsubscribe function that can be used to unsubscribe from the `comments` event.\n   */\n  function _subscribe(): () => void {\n    // Only subscribe to the `comments` event if the reference count is 0 (meaning that there are no components with a subscription)\n    if (commentsEventRefCount === 0) {\n      commentsEventDisposer = room.events.comments.subscribe(() => {\n        void revalidateCache(true);\n      });\n    }\n\n    commentsEventRefCount = commentsEventRefCount + 1;\n\n    return () => {\n      // Only unsubscribe from the `comments` event if the reference count is 0 (meaning that there are no components with a subscription)\n      commentsEventRefCount = commentsEventRefCount - 1;\n      if (commentsEventRefCount > 0) return;\n\n      commentsEventDisposer?.();\n      commentsEventDisposer = undefined;\n    };\n  }\n\n  function usePolling() {\n    const status = useSyncExternalStore(\n      room.events.status.subscribe,\n      room.getStatus,\n      room.getStatus\n    );\n\n    useEffect(\n      () => {\n        const interval =\n          status === \"connected\" ? POLLING_INTERVAL_REALTIME : POLLING_INTERVAL;\n\n        let revalidationTimerId: number;\n        function scheduleRevalidation() {\n          revalidationTimerId = window.setTimeout(\n            executeRevalidation,\n            interval\n          );\n        }\n\n        function executeRevalidation() {\n          // Revalidate cache and then schedule the next revalidation\n          void revalidateCache(true).then(scheduleRevalidation);\n        }\n\n        scheduleRevalidation();\n\n        return () => {\n          window.clearTimeout(revalidationTimerId);\n        };\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- ESLint recommends against adding `revalidateCache` as a dependency, but not doing so causes the code inside `useEffect` to reference an outdated version of `revalidateCache`\n      [status, revalidateCache]\n    );\n  }\n\n  function useThreadsInternal(): ThreadsState<TThreadMetadata> {\n    useEffect(_subscribe, [_subscribe]);\n\n    usePolling();\n\n    const cache = useSyncExternalStore(\n      manager.subscribe,\n      () => manager.cache,\n      () => manager.cache\n    );\n\n    return cache ?? { isLoading: true };\n  }\n\n  function useThreads() {\n    useEffect(\n      () => {\n        void revalidateCache(true);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- ESLint recommends against adding `revalidateCache` as a dependency, but not doing so causes the code inside `useEffect` to reference an outdated version of `revalidateCache`\n      [revalidateCache]\n    );\n\n    return useThreadsInternal();\n  }\n\n  function useThreadsSuspense(): ThreadsStateSuccess<TThreadMetadata> {\n    const cache = useThreadsInternal();\n\n    if (cache.isLoading) {\n      throw revalidateCache(true);\n    }\n\n    if (cache.error) {\n      throw cache.error;\n    }\n\n    return {\n      threads: cache.threads,\n      isLoading: false,\n    };\n  }\n\n  function addReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: CommentReactionOptions): void {\n    const threads = getThreads();\n    const now = new Date().toISOString();\n\n    const optimisticData = threads.map((thread) =>\n      thread.id === threadId\n        ? {\n            ...thread,\n            comments: thread.comments.map((comment) =>\n              comment.id === commentId\n                ? ({\n                    ...comment,\n                    reactions: [\n                      ...comment.reactions,\n                      { emoji, userId: getCurrentUserId(), createdAt: now },\n                    ],\n                  } as CommentData)\n                : comment\n            ),\n          }\n        : thread\n    );\n\n    mutate(room.addReaction({ threadId, commentId, emoji }), {\n      optimisticData,\n    }).catch((err: Error) => {\n      errorEventSource.notify(\n        new AddReactionError(err, {\n          roomId: room.id,\n          threadId,\n          commentId,\n          emoji,\n        })\n      );\n    });\n  }\n\n  function removeReaction({\n    threadId,\n    commentId,\n    emoji,\n  }: CommentReactionOptions): void {\n    const threads = getThreads();\n\n    const optimisticData = threads.map((thread) =>\n      thread.id === threadId\n        ? {\n            ...thread,\n            comments: thread.comments.map((comment) => {\n              const reactionIndex = comment.reactions.findIndex(\n                (reaction) =>\n                  reaction.emoji === emoji &&\n                  reaction.userId === getCurrentUserId()\n              );\n\n              return comment.id === commentId\n                ? ({\n                    ...comment,\n                    reactions:\n                      reactionIndex < 0\n                        ? comment.reactions\n                        : comment.reactions\n                            .slice(0, reactionIndex)\n                            .concat(comment.reactions.slice(reactionIndex + 1)),\n                  } as CommentData)\n                : comment;\n            }),\n          }\n        : thread\n    );\n\n    mutate(room.removeReaction({ threadId, commentId, emoji }), {\n      optimisticData,\n    }).catch((err: Error) => {\n      errorEventSource.notify(\n        new RemoveReactionError(err, {\n          roomId: room.id,\n          threadId,\n          commentId,\n          emoji,\n        })\n      );\n    });\n  }\n\n  return {\n    useThreads,\n    useThreadsSuspense,\n    editThreadMetadata,\n    addReaction,\n    removeReaction,\n    createThread,\n    createComment,\n    editComment,\n    deleteComment,\n  };\n}\n","import type { BaseMetadata, CommentBody } from \"@liveblocks/core\";\n\nexport class CreateThreadError<TMetadata extends BaseMetadata> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n      metadata: TMetadata;\n    }\n  ) {\n    super(\"Create thread failed.\");\n    this.name = \"CreateThreadError\";\n  }\n}\n\nexport class EditThreadMetadataError<\n  TMetadata extends BaseMetadata,\n> extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      metadata: Partial<TMetadata>;\n    }\n  ) {\n    super(\"Edit thread metadata failed.\");\n    this.name = \"EditThreadMetadataError\";\n  }\n}\n\nexport class CreateCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Create comment failed.\");\n    this.name = \"CreateCommentError\";\n  }\n}\n\nexport class EditCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      body: CommentBody;\n    }\n  ) {\n    super(\"Edit comment failed.\");\n    this.name = \"EditCommentError\";\n  }\n}\n\nexport class DeleteCommentError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n    }\n  ) {\n    super(\"Delete comment failed.\");\n    this.name = \"DeleteCommentError\";\n  }\n}\n\nexport class AddReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Add reaction failed.\");\n    this.name = \"AddReactionError\";\n  }\n}\n\nexport class RemoveReactionError extends Error {\n  constructor(\n    public cause: Error,\n    public context: {\n      roomId: string;\n      threadId: string;\n      commentId: string;\n      emoji: string;\n    }\n  ) {\n    super(\"Remove reaction failed.\");\n    this.name = \"RemoveReactionError\";\n  }\n}\n\nexport type CommentsApiError<TThreadMetadata extends BaseMetadata> =\n  | CreateThreadError<TThreadMetadata>\n  | EditThreadMetadataError<TThreadMetadata>\n  | CreateCommentError\n  | EditCommentError\n  | DeleteCommentError;\n","import { useEffect, useRef, useState } from \"react\";\n\nconst DEFAULT_DELAY = 500;\n\nexport function useDebounce<T>(\n  value: T,\n  delay: number | false = DEFAULT_DELAY\n): T {\n  const timeout = useRef<number>();\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    if (delay === false) {\n      return;\n    }\n\n    if (timeout.current === undefined) {\n      setDebouncedValue(value);\n    }\n\n    timeout.current = window.setTimeout(() => {\n      setDebouncedValue(value);\n      timeout.current = undefined;\n    }, delay);\n\n    return () => {\n      window.clearTimeout(timeout.current);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\ntype OmitFirstTupleElement<T extends any[]> = T extends [any, ...infer R]\n  ? R\n  : never;\n\nexport function stableStringify(\n  object: Parameters<typeof JSON.stringify>[0],\n  ...args: OmitFirstTupleElement<Parameters<typeof JSON.stringify>>\n) {\n  const sortedObject = Object.keys(object)\n    .sort()\n    .reduce(\n      (sortedObject, key) => {\n        sortedObject[key] = object[key];\n\n        return sortedObject;\n      },\n      {} as Record<string, any>\n    );\n\n  return JSON.stringify(sortedObject, ...args);\n}\n","import type {\n  AsyncCache,\n  AsyncState,\n  AsyncStateInitial,\n  AsyncStateResolved,\n} from \"@liveblocks/core\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nimport { useInitial } from \"./use-initial\";\n\nconst INITIAL_ASYNC_STATE: AsyncStateInitial = {\n  isLoading: false,\n  data: undefined,\n  error: undefined,\n};\n\ntype AsyncFunction<T, A extends any[] = any[]> = (...args: A) => Promise<T>;\n\nexport type UseAsyncCacheOptions<T> = {\n  overrideFunction?: AsyncFunction<T, [string]>;\n  keepPreviousDataWhileLoading?: boolean;\n  suspense?: boolean;\n};\n\ntype UseAsyncCacheState<\n  T,\n  E,\n  O extends UseAsyncCacheOptions<T> = UseAsyncCacheOptions<T>,\n> = O extends {\n  suspense: true;\n}\n  ? Exclude<AsyncState<T, E>, { isLoading: true }>\n  : AsyncState<T, E>;\n\nexport type UseAsyncCacheResponse<\n  T,\n  E,\n  O extends UseAsyncCacheOptions<T> = UseAsyncCacheOptions<T>,\n> = UseAsyncCacheState<T, E, O> & {\n  /**\n   * Returns the current state of the key synchronously.\n   */\n  getState: () => AsyncState<T, E>;\n\n  /**\n   * Revalidates the key.\n   */\n  revalidate(): Promise<AsyncStateResolved<T, E>>;\n};\n\ntype PreviousData<T> = {\n  key: string | null;\n  data?: T;\n};\n\nconst noop = () => {};\n\nexport function useAsyncCache<T, E, O extends UseAsyncCacheOptions<T>>(\n  cache: AsyncCache<T, E> | undefined,\n  key: string | null,\n  options?: O\n): UseAsyncCacheResponse<T, E, O> {\n  const frozenOptions = useInitial(options);\n  const cacheItem = useMemo(() => {\n    if (key === null || !cache) {\n      return null;\n    }\n\n    const cacheItem = cache.create(key, frozenOptions?.overrideFunction);\n    void cacheItem.get();\n\n    return cacheItem;\n  }, [cache, frozenOptions, key]);\n\n  const subscribe = useCallback(\n    (callback: () => void) => cacheItem?.subscribe(callback) ?? noop,\n    [cacheItem]\n  );\n\n  const getState = useCallback(\n    () => cacheItem?.getState() ?? INITIAL_ASYNC_STATE,\n    [cacheItem]\n  );\n\n  const revalidate = useCallback(() => cacheItem?.revalidate(), [cacheItem]);\n\n  const state = useSyncExternalStore(subscribe, getState, getState);\n  const previousData = useRef<PreviousData<T>>();\n  let data = state.data;\n\n  useEffect(() => {\n    previousData.current = { key, data: state.data };\n  }, [key, state]);\n\n  if (frozenOptions?.suspense && state.isLoading && cacheItem) {\n    throw new Promise<void>((resolve) => {\n      cacheItem.subscribeOnce(() => resolve());\n    });\n  }\n\n  if (\n    state.isLoading &&\n    frozenOptions?.keepPreviousDataWhileLoading &&\n    typeof state.data === \"undefined\" &&\n    previousData.current?.key !== key &&\n    typeof previousData.current?.data !== \"undefined\"\n  ) {\n    data = previousData.current.data;\n  }\n\n  if (frozenOptions?.suspense && state.error) {\n    throw state.error;\n  }\n\n  return {\n    isLoading: state.isLoading,\n    data,\n    error: state.error,\n    getState,\n    revalidate,\n  } as UseAsyncCacheResponse<T, E, O>;\n}\n","import { useRef } from \"react\";\n\n/**\n * \"Freezes\" a given value, so that it will return the same value/instance on\n * each subsequent render. This can be used to freeze \"initial\" values for\n * custom hooks, much like how `useState(initialState)` or\n * `useRef(initialValue)` works.\n */\nexport function useInitial<T>(value: T): T {\n  return useRef(value).current;\n}\n","import { useReducer } from \"react\";\n\n/**\n * Trigger a re-render programmatically, without changing the component's\n * state.\n *\n * @example\n * const rerender = useRerender();\n *\n * return (\n *   <button onClick={rerender}>\n *     {Math.random()}\n *   </button>\n * )\n */\nexport function useRerender(): () => void {\n  const [, update] = useReducer(\n    // This implementation works by incrementing a hidden counter value that is\n    // never consumed. Simply incrementing the counter changes the component's\n    // state and, thus, trigger a re-render.\n    (x: number): number => x + 1,\n    0\n  );\n  return update;\n}\n"],"mappings":"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","names":["makeEventSource","React","useEffect","useEffect","useEffect","useState","sortedObject","useEffect","useRef","useSyncExternalStore","useRef","cacheItem","useSyncExternalStore","useRef","useEffect","noop","useSyncExternalStore","room","other","options","rootOrNull","makeEventSource","shallow"]}