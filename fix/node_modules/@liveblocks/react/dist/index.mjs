"use client";

// src/index.ts
import { detectDupes } from "@liveblocks/core";

// src/version.ts
var PKG_NAME = "@liveblocks/react";
var PKG_VERSION = "1.4.0";
var PKG_FORMAT = "esm";

// src/ClientSideSuspense.tsx
import * as React from "react";
function ClientSideSuspense(props) {
  const [mounted, setMounted] = React.useState(false);
  React.useEffect(() => {
    setMounted(true);
  }, []);
  return /* @__PURE__ */ React.createElement(React.Suspense, { fallback: props.fallback }, mounted ? props.children() : props.fallback);
}

// src/factory.tsx
import { shallow } from "@liveblocks/client";
import {
  createAsyncCache,
  deprecateIf,
  errorIf,
  isLiveNode,
  makeEventSource as makeEventSource2
} from "@liveblocks/core";
import * as React2 from "react";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";

// src/comments/CommentsRoom.ts
import { makeEventSource } from "@liveblocks/core";
import { nanoid } from "nanoid";
import { useEffect as useEffect2 } from "react";
import { useSyncExternalStore } from "use-sync-external-store/shim/index.js";

// src/comments/errors.ts
var CreateThreadError = class extends Error {
  constructor(cause, context) {
    super("Create thread failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateThreadError";
  }
};
var EditThreadMetadataError = class extends Error {
  constructor(cause, context) {
    super("Edit thread metadata failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditThreadMetadataError";
  }
};
var CreateCommentError = class extends Error {
  constructor(cause, context) {
    super("Create comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "CreateCommentError";
  }
};
var EditCommentError = class extends Error {
  constructor(cause, context) {
    super("Edit comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "EditCommentError";
  }
};
var DeleteCommentError = class extends Error {
  constructor(cause, context) {
    super("Delete comment failed.");
    this.cause = cause;
    this.context = context;
    this.name = "DeleteCommentError";
  }
};
var AddReactionError = class extends Error {
  constructor(cause, context) {
    super("Add reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "AddReactionError";
  }
};
var RemoveReactionError = class extends Error {
  constructor(cause, context) {
    super("Remove reaction failed.");
    this.cause = cause;
    this.context = context;
    this.name = "RemoveReactionError";
  }
};

// src/comments/CommentsRoom.ts
var POLLING_INTERVAL_REALTIME = 3e4;
var POLLING_INTERVAL = 5e3;
var MAX_ERROR_RETRY_COUNT = 5;
var ERROR_RETRY_INTERVAL = 5e3;
var THREAD_ID_PREFIX = "th";
var COMMENT_ID_PREFIX = "cm";
var DEDUPING_INTERVAL = 1e3;
function createOptimisticId(prefix) {
  return `${prefix}_${nanoid()}`;
}
function createThreadsManager() {
  let cache;
  let request;
  let mutation;
  const eventSource = makeEventSource();
  return {
    get cache() {
      return cache;
    },
    set cache(value) {
      cache = value;
      eventSource.notify(cache);
    },
    get request() {
      return request;
    },
    set request(value) {
      request = value;
    },
    get mutation() {
      return mutation;
    },
    set mutation(value) {
      mutation = value;
    },
    subscribe(callback) {
      return eventSource.subscribe(callback);
    }
  };
}
function createCommentsRoom(room, errorEventSource) {
  const manager = createThreadsManager();
  let timestamp = 0;
  let commentsEventRefCount = 0;
  let commentsEventDisposer;
  async function mutate(data, options) {
    const beforeMutationTimestamp = ++timestamp;
    manager.mutation = {
      startTime: beforeMutationTimestamp,
      endTime: 0
    };
    const currentCache = manager.cache;
    manager.cache = {
      isLoading: false,
      threads: options.optimisticData
    };
    try {
      await data;
      const activeMutation = manager.mutation;
      if (activeMutation && beforeMutationTimestamp !== activeMutation.startTime) {
        return;
      }
    } catch (err) {
      manager.cache = currentCache;
      throw err;
    }
    manager.mutation = {
      startTime: beforeMutationTimestamp,
      endTime: ++timestamp
    };
    manager.request = void 0;
    void revalidateCache(false);
  }
  async function revalidateCache(shouldDedupe, retryCount = 0) {
    let startAt;
    const shouldStartRequest = !manager.request || !shouldDedupe;
    function deleteActiveRequest() {
      const activeRequest = manager.request;
      if (!activeRequest)
        return;
      if (activeRequest.timestamp !== startAt)
        return;
      manager.request = void 0;
    }
    function handleError() {
      const timeout = ~~((Math.random() + 0.5) * (1 << (retryCount < 8 ? retryCount : 8))) * ERROR_RETRY_INTERVAL;
      if (retryCount > MAX_ERROR_RETRY_COUNT)
        return;
      setTimeout(() => {
        void revalidateCache(true, retryCount + 1);
      }, timeout);
    }
    try {
      if (shouldStartRequest) {
        const currentCache = manager.cache;
        if (!currentCache)
          manager.cache = { isLoading: true };
        manager.request = {
          fetcher: room.getThreads(),
          timestamp: ++timestamp
        };
      }
      const activeRequest = manager.request;
      if (!activeRequest)
        return;
      const newData = await activeRequest.fetcher;
      startAt = activeRequest.timestamp;
      if (shouldStartRequest) {
        setTimeout(deleteActiveRequest, DEDUPING_INTERVAL);
      }
      if (!manager.request || manager.request.timestamp !== startAt)
        return;
      const activeMutation = manager.mutation;
      if (activeMutation && (activeMutation.startTime > startAt || activeMutation.endTime > startAt || activeMutation.endTime === 0)) {
        return;
      }
      manager.cache = {
        isLoading: false,
        threads: newData
      };
    } catch (err) {
      if (shouldStartRequest)
        handleError();
      deleteActiveRequest();
      manager.cache = {
        isLoading: false,
        error: err
      };
    }
  }
  function editThreadMetadata(options) {
    const threadId = options.threadId;
    const metadata = "metadata" in options ? options.metadata : {};
    const threads = getThreads();
    const optimisticData = threads.map(
      (thread) => thread.id === threadId ? {
        ...thread,
        metadata: {
          ...thread.metadata,
          ...metadata
        }
      } : thread
    );
    mutate(room.editThreadMetadata({ metadata, threadId }), {
      optimisticData
    }).catch((err) => {
      errorEventSource.notify(
        new EditThreadMetadataError(err, {
          roomId: room.id,
          threadId,
          metadata
        })
      );
    });
  }
  function createThread(options) {
    const body = options.body;
    const metadata = "metadata" in options ? options.metadata : {};
    const threads = getThreads();
    const threadId = createOptimisticId(THREAD_ID_PREFIX);
    const commentId = createOptimisticId(COMMENT_ID_PREFIX);
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const newThread = {
      id: threadId,
      type: "thread",
      createdAt: now,
      roomId: room.id,
      metadata,
      comments: [
        {
          id: commentId,
          createdAt: now,
          type: "comment",
          userId: getCurrentUserId(),
          body
        }
      ]
    };
    mutate(room.createThread({ threadId, commentId, body, metadata }), {
      optimisticData: [...threads, newThread]
    }).catch(
      (er) => errorEventSource.notify(
        new CreateThreadError(er, {
          roomId: room.id,
          threadId,
          commentId,
          body,
          metadata
        })
      )
    );
    return newThread;
  }
  function createComment({
    threadId,
    body
  }) {
    const threads = getThreads();
    const commentId = createOptimisticId(COMMENT_ID_PREFIX);
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const comment = {
      id: commentId,
      threadId,
      roomId: room.id,
      type: "comment",
      createdAt: now,
      userId: getCurrentUserId(),
      body,
      reactions: []
    };
    const optimisticData = threads.map(
      (thread) => thread.id === threadId ? {
        ...thread,
        comments: [...thread.comments, comment]
      } : thread
    );
    mutate(room.createComment({ threadId, commentId, body }), {
      optimisticData
    }).catch(
      (er) => errorEventSource.notify(
        new CreateCommentError(er, {
          roomId: room.id,
          threadId,
          commentId,
          body
        })
      )
    );
    return comment;
  }
  function editComment({ threadId, commentId, body }) {
    const threads = getThreads();
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const optimisticData = threads.map(
      (thread) => thread.id === threadId ? {
        ...thread,
        comments: thread.comments.map(
          (comment) => comment.id === commentId ? {
            ...comment,
            editedAt: now,
            body
          } : comment
        )
      } : thread
    );
    mutate(room.editComment({ threadId, commentId, body }), {
      optimisticData
    }).catch(
      (er) => errorEventSource.notify(
        new EditCommentError(er, {
          roomId: room.id,
          threadId,
          commentId,
          body
        })
      )
    );
  }
  function deleteComment({ threadId, commentId }) {
    const threads = getThreads();
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const newThreads = [];
    for (const thread of threads) {
      if (thread.id === threadId) {
        const newThread = {
          ...thread,
          comments: thread.comments.map(
            (comment) => comment.id === commentId ? {
              ...comment,
              deletedAt: now,
              body: void 0
            } : comment
          )
        };
        if (newThread.comments.some((comment) => comment.deletedAt === void 0)) {
          newThreads.push(newThread);
        }
      } else {
        newThreads.push(thread);
      }
    }
    mutate(room.deleteComment({ threadId, commentId }), {
      optimisticData: newThreads
    }).catch(
      (er) => errorEventSource.notify(
        new DeleteCommentError(er, {
          roomId: room.id,
          threadId,
          commentId
        })
      )
    );
  }
  function getCurrentUserId() {
    const self = room.getSelf();
    if (self === null || self.id === void 0) {
      return "anonymous";
    } else {
      return self.id;
    }
  }
  function getThreads() {
    const threads = manager.cache;
    if (!threads || threads.isLoading || threads.error) {
      throw new Error(
        "Cannot update threads or comments before they are loaded."
      );
    }
    return threads.threads;
  }
  function _subscribe() {
    if (commentsEventRefCount === 0) {
      commentsEventDisposer = room.events.comments.subscribe(() => {
        void revalidateCache(true);
      });
    }
    commentsEventRefCount = commentsEventRefCount + 1;
    return () => {
      commentsEventRefCount = commentsEventRefCount - 1;
      if (commentsEventRefCount > 0)
        return;
      commentsEventDisposer?.();
      commentsEventDisposer = void 0;
    };
  }
  function usePolling() {
    const status = useSyncExternalStore(
      room.events.status.subscribe,
      room.getStatus,
      room.getStatus
    );
    useEffect2(
      () => {
        const interval = status === "connected" ? POLLING_INTERVAL_REALTIME : POLLING_INTERVAL;
        let revalidationTimerId;
        function scheduleRevalidation() {
          revalidationTimerId = window.setTimeout(
            executeRevalidation,
            interval
          );
        }
        function executeRevalidation() {
          void revalidateCache(true).then(scheduleRevalidation);
        }
        scheduleRevalidation();
        return () => {
          window.clearTimeout(revalidationTimerId);
        };
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- ESLint recommends against adding `revalidateCache` as a dependency, but not doing so causes the code inside `useEffect` to reference an outdated version of `revalidateCache`
      [status, revalidateCache]
    );
  }
  function useThreadsInternal() {
    useEffect2(_subscribe, [_subscribe]);
    usePolling();
    const cache = useSyncExternalStore(
      manager.subscribe,
      () => manager.cache,
      () => manager.cache
    );
    return cache ?? { isLoading: true };
  }
  function useThreads() {
    useEffect2(
      () => {
        void revalidateCache(true);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps -- ESLint recommends against adding `revalidateCache` as a dependency, but not doing so causes the code inside `useEffect` to reference an outdated version of `revalidateCache`
      [revalidateCache]
    );
    return useThreadsInternal();
  }
  function useThreadsSuspense() {
    const cache = useThreadsInternal();
    if (cache.isLoading) {
      throw revalidateCache(true);
    }
    if (cache.error) {
      throw cache.error;
    }
    return {
      threads: cache.threads,
      isLoading: false
    };
  }
  function addReaction({
    threadId,
    commentId,
    emoji
  }) {
    const threads = getThreads();
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const optimisticData = threads.map(
      (thread) => thread.id === threadId ? {
        ...thread,
        comments: thread.comments.map(
          (comment) => comment.id === commentId ? {
            ...comment,
            reactions: [
              ...comment.reactions,
              { emoji, userId: getCurrentUserId(), createdAt: now }
            ]
          } : comment
        )
      } : thread
    );
    mutate(room.addReaction({ threadId, commentId, emoji }), {
      optimisticData
    }).catch((err) => {
      errorEventSource.notify(
        new AddReactionError(err, {
          roomId: room.id,
          threadId,
          commentId,
          emoji
        })
      );
    });
  }
  function removeReaction({
    threadId,
    commentId,
    emoji
  }) {
    const threads = getThreads();
    const optimisticData = threads.map(
      (thread) => thread.id === threadId ? {
        ...thread,
        comments: thread.comments.map((comment) => {
          const reactionIndex = comment.reactions.findIndex(
            (reaction) => reaction.emoji === emoji && reaction.userId === getCurrentUserId()
          );
          return comment.id === commentId ? {
            ...comment,
            reactions: reactionIndex < 0 ? comment.reactions : comment.reactions.slice(0, reactionIndex).concat(comment.reactions.slice(reactionIndex + 1))
          } : comment;
        })
      } : thread
    );
    mutate(room.removeReaction({ threadId, commentId, emoji }), {
      optimisticData
    }).catch((err) => {
      errorEventSource.notify(
        new RemoveReactionError(err, {
          roomId: room.id,
          threadId,
          commentId,
          emoji
        })
      );
    });
  }
  return {
    useThreads,
    useThreadsSuspense,
    editThreadMetadata,
    addReaction,
    removeReaction,
    createThread,
    createComment,
    editComment,
    deleteComment
  };
}

// src/comments/lib/use-debounce.ts
import { useEffect as useEffect3, useRef, useState as useState2 } from "react";
var DEFAULT_DELAY = 500;
function useDebounce(value, delay = DEFAULT_DELAY) {
  const timeout = useRef();
  const [debouncedValue, setDebouncedValue] = useState2(value);
  useEffect3(() => {
    if (delay === false) {
      return;
    }
    if (timeout.current === void 0) {
      setDebouncedValue(value);
    }
    timeout.current = window.setTimeout(() => {
      setDebouncedValue(value);
      timeout.current = void 0;
    }, delay);
    return () => {
      window.clearTimeout(timeout.current);
    };
  }, [value, delay]);
  return debouncedValue;
}

// src/lib/stable-stringify.ts
function stableStringify(object, ...args) {
  const sortedObject = Object.keys(object).sort().reduce(
    (sortedObject2, key) => {
      sortedObject2[key] = object[key];
      return sortedObject2;
    },
    {}
  );
  return JSON.stringify(sortedObject, ...args);
}

// src/lib/use-async-cache.ts
import { useCallback, useEffect as useEffect4, useMemo, useRef as useRef3 } from "react";
import { useSyncExternalStore as useSyncExternalStore2 } from "use-sync-external-store/shim/index.js";

// src/lib/use-initial.ts
import { useRef as useRef2 } from "react";
function useInitial(value) {
  return useRef2(value).current;
}

// src/lib/use-async-cache.ts
var INITIAL_ASYNC_STATE = {
  isLoading: false,
  data: void 0,
  error: void 0
};
var noop = () => {
};
function useAsyncCache(cache, key, options) {
  const frozenOptions = useInitial(options);
  const cacheItem = useMemo(() => {
    if (key === null || !cache) {
      return null;
    }
    const cacheItem2 = cache.create(key, frozenOptions?.overrideFunction);
    void cacheItem2.get();
    return cacheItem2;
  }, [cache, frozenOptions, key]);
  const subscribe = useCallback(
    (callback) => cacheItem?.subscribe(callback) ?? noop,
    [cacheItem]
  );
  const getState = useCallback(
    () => cacheItem?.getState() ?? INITIAL_ASYNC_STATE,
    [cacheItem]
  );
  const revalidate = useCallback(() => cacheItem?.revalidate(), [cacheItem]);
  const state = useSyncExternalStore2(subscribe, getState, getState);
  const previousData = useRef3();
  let data = state.data;
  useEffect4(() => {
    previousData.current = { key, data: state.data };
  }, [key, state]);
  if (frozenOptions?.suspense && state.isLoading && cacheItem) {
    throw new Promise((resolve) => {
      cacheItem.subscribeOnce(() => resolve());
    });
  }
  if (state.isLoading && frozenOptions?.keepPreviousDataWhileLoading && typeof state.data === "undefined" && previousData.current?.key !== key && typeof previousData.current?.data !== "undefined") {
    data = previousData.current.data;
  }
  if (frozenOptions?.suspense && state.error) {
    throw state.error;
  }
  return {
    isLoading: state.isLoading,
    data,
    error: state.error,
    getState,
    revalidate
  };
}

// src/lib/use-rerender.ts
import { useReducer } from "react";
function useRerender() {
  const [, update] = useReducer(
    // This implementation works by incrementing a hidden counter value that is
    // never consumed. Simply incrementing the counter changes the component's
    // state and, thus, trigger a re-render.
    (x) => x + 1,
    0
  );
  return update;
}

// src/factory.tsx
var noop2 = () => {
};
var identity = (x) => x;
var missing_unstable_batchedUpdates = (reactVersion, roomId) => `We noticed you\u2019re using React ${reactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(
  roomId
)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/guides/troubleshooting#stale-props-zombie-child for more information`;
var superfluous_unstable_batchedUpdates = "You don\u2019t need to pass unstable_batchedUpdates to RoomProvider anymore, since you\u2019re on React 18+ already.";
function useSyncExternalStore3(s, gs, gss) {
  return useSyncExternalStoreWithSelector(s, gs, gss, identity);
}
function getEmptyOthers() {
  return [];
}
function makeMutationContext(room) {
  const errmsg = "This mutation cannot be used until connected to the Liveblocks room";
  return {
    get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (mutableRoot === null) {
        throw new Error(errmsg);
      }
      return mutableRoot;
    },
    get self() {
      const self = room.getSelf();
      if (self === null) {
        throw new Error(errmsg);
      }
      return self;
    },
    get others() {
      const others = room.getOthers();
      if (room.getSelf() === null) {
        throw new Error(errmsg);
      }
      return others;
    },
    setMyPresence: room.updatePresence
  };
}
var hasWarnedIfNoResolveUser = false;
function warnIfNoResolveUser(usersCache) {
  if (!hasWarnedIfNoResolveUser && !usersCache && process.env.NODE_ENV !== "production") {
    console.warn(
      "Set the resolveUser option in createRoomContext to specify user info."
    );
    hasWarnedIfNoResolveUser = true;
  }
}
var hasWarnedAboutCommentsBeta = false;
function warnIfBetaCommentsHook() {
  if (!hasWarnedAboutCommentsBeta && process.env.NODE_ENV !== "production") {
    console.warn(
      "Comments is currently in private beta. Learn more at https://liveblocks.io/docs/products/comments."
    );
    hasWarnedAboutCommentsBeta = true;
  }
}
var ContextBundle = React2.createContext(null);
function useRoomContextBundle() {
  const bundle = React2.useContext(ContextBundle);
  if (bundle === null) {
    throw new Error("RoomProvider is missing from the React tree.");
  }
  return bundle;
}
function createRoomContext(client, options) {
  const RoomContext = React2.createContext(null);
  function RoomProvider(props) {
    const {
      id: roomId,
      initialPresence,
      initialStorage,
      unstable_batchedUpdates,
      shouldInitiallyConnect
    } = props;
    if (process.env.NODE_ENV !== "production") {
      if (!roomId) {
        throw new Error(
          "RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required"
        );
      }
      if (typeof roomId !== "string") {
        throw new Error("RoomProvider id property should be a string.");
      }
      const majorReactVersion = parseInt(React2.version) || 1;
      const oldReactVersion = majorReactVersion < 18;
      errorIf(
        oldReactVersion && props.unstable_batchedUpdates === void 0,
        missing_unstable_batchedUpdates(majorReactVersion, roomId)
      );
      deprecateIf(
        !oldReactVersion && props.unstable_batchedUpdates !== void 0,
        superfluous_unstable_batchedUpdates
      );
    }
    const frozen = useInitial({
      initialPresence,
      initialStorage,
      unstable_batchedUpdates,
      shouldInitiallyConnect: shouldInitiallyConnect === void 0 ? typeof window !== "undefined" : shouldInitiallyConnect
    });
    const [room, setRoom] = React2.useState(
      () => client.enter(roomId, {
        initialPresence: frozen.initialPresence,
        initialStorage: frozen.initialStorage,
        shouldInitiallyConnect: frozen.shouldInitiallyConnect,
        unstable_batchedUpdates: frozen.unstable_batchedUpdates
      })
    );
    React2.useEffect(() => {
      const room2 = client.enter(
        roomId,
        {
          initialPresence: frozen.initialPresence,
          initialStorage: frozen.initialStorage,
          shouldInitiallyConnect: frozen.shouldInitiallyConnect,
          unstable_batchedUpdates: frozen.unstable_batchedUpdates
        }
      );
      setRoom(room2);
      return () => {
        const commentsRoom = commentsRooms.get(room2);
        if (commentsRoom) {
          commentsRooms.delete(room2);
        }
        client.leave(roomId);
      };
    }, [roomId, frozen]);
    return /* @__PURE__ */ React2.createElement(RoomContext.Provider, { value: room }, /* @__PURE__ */ React2.createElement(
      ContextBundle.Provider,
      {
        value: internalBundle
      },
      props.children
    ));
  }
  function connectionIdSelector(others) {
    return others.map((user) => user.connectionId);
  }
  function useRoom() {
    const room = React2.useContext(RoomContext);
    if (room === null) {
      throw new Error("RoomProvider is missing from the React tree.");
    }
    return room;
  }
  function useStatus() {
    const room = useRoom();
    const subscribe = room.events.status.subscribe;
    const getSnapshot = room.getStatus;
    return useSyncExternalStore3(subscribe, getSnapshot, getSnapshot);
  }
  function useMyPresence() {
    const room = useRoom();
    const subscribe = room.events.myPresence.subscribe;
    const getSnapshot = room.getPresence;
    const presence = useSyncExternalStore3(subscribe, getSnapshot, getSnapshot);
    const setPresence = room.updatePresence;
    return [presence, setPresence];
  }
  function useUpdateMyPresence() {
    return useRoom().updatePresence;
  }
  function useOthers(selector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.others.subscribe;
    const getSnapshot = room.getOthers;
    const getServerSnapshot = getEmptyOthers;
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      selector ?? identity,
      isEqual
    );
  }
  function useOthersConnectionIds() {
    return useOthers(connectionIdSelector, shallow);
  }
  function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = React2.useCallback(
      (others) => others.map(
        (other) => [other.connectionId, itemSelector(other)]
      ),
      [itemSelector]
    );
    const wrappedIsEqual = React2.useCallback(
      (a, b) => {
        const eq = itemIsEqual ?? Object.is;
        return a.length === b.length && a.every((atuple, index) => {
          const btuple = b[index];
          return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);
        });
      },
      [itemIsEqual]
    );
    return useOthers(wrappedSelector, wrappedIsEqual);
  }
  const NOT_FOUND = Symbol();
  function useOther(connectionId, selector, isEqual) {
    const wrappedSelector = React2.useCallback(
      (others) => {
        const other2 = others.find(
          (other3) => other3.connectionId === connectionId
        );
        return other2 !== void 0 ? selector(other2) : NOT_FOUND;
      },
      [connectionId, selector]
    );
    const wrappedIsEqual = React2.useCallback(
      (prev, curr) => {
        if (prev === NOT_FOUND || curr === NOT_FOUND) {
          return prev === curr;
        }
        const eq = isEqual ?? Object.is;
        return eq(prev, curr);
      },
      [isEqual]
    );
    const other = useOthers(wrappedSelector, wrappedIsEqual);
    if (other === NOT_FOUND) {
      throw new Error(
        `No such other user with connection id ${connectionId} exists`
      );
    }
    return other;
  }
  function useBroadcastEvent() {
    const room = useRoom();
    return React2.useCallback(
      (event, options2 = { shouldQueueEventIfNotReady: false }) => {
        room.broadcastEvent(event, options2);
      },
      [room]
    );
  }
  function useLostConnectionListener(callback) {
    const room = useRoom();
    const savedCallback = React2.useRef(callback);
    React2.useEffect(() => {
      savedCallback.current = callback;
    });
    React2.useEffect(
      () => room.events.lostConnection.subscribe(
        (event) => savedCallback.current(event)
      ),
      [room]
    );
  }
  function useErrorListener(callback) {
    const room = useRoom();
    const savedCallback = React2.useRef(callback);
    React2.useEffect(() => {
      savedCallback.current = callback;
    });
    React2.useEffect(
      () => room.events.error.subscribe((e) => savedCallback.current(e)),
      [room]
    );
  }
  function useEventListener(callback) {
    const room = useRoom();
    const savedCallback = React2.useRef(callback);
    React2.useEffect(() => {
      savedCallback.current = callback;
    });
    React2.useEffect(() => {
      const listener = (eventData) => {
        savedCallback.current(eventData);
      };
      return room.events.customEvent.subscribe(listener);
    }, [room]);
  }
  function useSelf(maybeSelector, isEqual) {
    const room = useRoom();
    const subscribe = room.events.self.subscribe;
    const getSnapshot = room.getSelf;
    const selector = maybeSelector ?? identity;
    const wrappedSelector = React2.useCallback(
      (me) => me !== null ? selector(me) : null,
      [selector]
    );
    const getServerSnapshot = React2.useCallback(() => null, []);
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function useMutableStorageRoot() {
    const room = useRoom();
    const subscribe = room.events.storageDidLoad.subscribeOnce;
    const getSnapshot = room.getStorageSnapshot;
    const getServerSnapshot = React2.useCallback(() => null, []);
    return useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot);
  }
  function useStorageRoot() {
    return [useMutableStorageRoot()];
  }
  function useHistory() {
    return useRoom().history;
  }
  function useUndo() {
    return useHistory().undo;
  }
  function useRedo() {
    return useHistory().redo;
  }
  function useCanUndo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canUndo = room.history.canUndo;
    return useSyncExternalStore3(subscribe, canUndo, canUndo);
  }
  function useCanRedo() {
    const room = useRoom();
    const subscribe = room.events.history.subscribe;
    const canRedo = room.history.canRedo;
    return useSyncExternalStore3(subscribe, canRedo, canRedo);
  }
  function useBatch() {
    return useRoom().batch;
  }
  function useLegacyKey(key) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const rerender = useRerender();
    React2.useEffect(() => {
      if (rootOrNull === null) {
        return;
      }
      const root = rootOrNull;
      let unsubCurr;
      let curr = root.get(key);
      function subscribeToCurr() {
        unsubCurr = isLiveNode(curr) ? room.subscribe(curr, rerender) : void 0;
      }
      function onRootChange() {
        const newValue = root.get(key);
        if (newValue !== curr) {
          unsubCurr?.();
          curr = newValue;
          subscribeToCurr();
          rerender();
        }
      }
      subscribeToCurr();
      rerender();
      const unsubscribeRoot = room.subscribe(root, onRootChange);
      return () => {
        unsubscribeRoot();
        unsubCurr?.();
      };
    }, [rootOrNull, room, key, rerender]);
    if (rootOrNull === null) {
      return null;
    } else {
      return rootOrNull.get(key);
    }
  }
  function useStorage(selector, isEqual) {
    const room = useRoom();
    const rootOrNull = useMutableStorageRoot();
    const wrappedSelector = React2.useCallback(
      (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,
      [selector]
    );
    const subscribe = React2.useCallback(
      (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop2,
      [room, rootOrNull]
    );
    const getSnapshot = React2.useCallback(() => {
      if (rootOrNull === null) {
        return null;
      } else {
        const root = rootOrNull;
        const imm = root.toImmutable();
        return imm;
      }
    }, [rootOrNull]);
    const getServerSnapshot = React2.useCallback(() => null, []);
    return useSyncExternalStoreWithSelector(
      subscribe,
      getSnapshot,
      getServerSnapshot,
      wrappedSelector,
      isEqual
    );
  }
  function ensureNotServerSide() {
    if (typeof window === "undefined") {
      throw new Error(
        "You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr"
      );
    }
  }
  function useSuspendUntilStorageLoaded() {
    const room = useRoom();
    if (room.getStorageSnapshot() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.storageDidLoad.subscribeOnce(() => res());
    });
  }
  function useSuspendUntilPresenceLoaded() {
    const room = useRoom();
    if (room.getSelf() !== null) {
      return;
    }
    ensureNotServerSide();
    throw new Promise((res) => {
      room.events.status.subscribeOnce(() => res());
    });
  }
  function useMutation(callback, deps) {
    const room = useRoom();
    return React2.useMemo(
      () => {
        return (...args) => (
          // eslint-disable-next-line @typescript-eslint/no-unsafe-return
          room.batch(
            () => (
              // eslint-disable-next-line @typescript-eslint/no-unsafe-return
              callback(
                makeMutationContext(room),
                ...args
              )
            )
          )
        );
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [room, ...deps]
    );
  }
  function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageLoaded();
    return useStorage(
      selector,
      isEqual
    );
  }
  function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useSelf(
      selector,
      isEqual
    );
  }
  function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthers(
      selector,
      isEqual
    );
  }
  function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceLoaded();
    return useOthersConnectionIds();
  }
  function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceLoaded();
    return useOthersMapped(itemSelector, itemIsEqual);
  }
  function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceLoaded();
    return useOther(connectionId, selector, isEqual);
  }
  function useLegacyKeySuspense(key) {
    useSuspendUntilStorageLoaded();
    return useLegacyKey(key);
  }
  const commentsErrorEventSource = makeEventSource2();
  const commentsRooms = /* @__PURE__ */ new Map();
  function getCommentsRoom(room) {
    let commentsRoom = commentsRooms.get(room);
    if (commentsRoom === void 0) {
      commentsRoom = createCommentsRoom(room, commentsErrorEventSource);
      commentsRooms.set(room, commentsRoom);
    }
    return commentsRoom;
  }
  function useThreads() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return getCommentsRoom(room).useThreads();
  }
  function useThreadsSuspense() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return getCommentsRoom(room).useThreadsSuspense();
  }
  function useCreateThread() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).createThread(options2),
      [room]
    );
  }
  function useEditThreadMetadata() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).editThreadMetadata(options2),
      [room]
    );
  }
  function useAddReaction() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).addReaction(options2),
      [room]
    );
  }
  function useRemoveReaction() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).removeReaction(options2),
      [room]
    );
  }
  function useCreateComment() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).createComment(options2),
      [room]
    );
  }
  function useEditComment() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).editComment(options2),
      [room]
    );
  }
  function useDeleteComment() {
    const room = useRoom();
    React2.useEffect(() => {
      warnIfBetaCommentsHook();
    }, []);
    return React2.useCallback(
      (options2) => getCommentsRoom(room).deleteComment(options2),
      [room]
    );
  }
  const { resolveUser, resolveMentionSuggestions } = options ?? {};
  const usersCache = resolveUser ? createAsyncCache((stringifiedOptions) => {
    return resolveUser(
      JSON.parse(stringifiedOptions)
    );
  }) : void 0;
  function useUser(userId) {
    const resolverKey = React2.useMemo(
      () => stableStringify({ userId }),
      [userId]
    );
    const state = useAsyncCache(usersCache, resolverKey);
    React2.useEffect(() => warnIfNoResolveUser(usersCache), []);
    if (state.isLoading) {
      return {
        isLoading: true
      };
    } else {
      return {
        user: state.data,
        error: state.error,
        isLoading: false
      };
    }
  }
  function useUserSuspense(userId) {
    const resolverKey = React2.useMemo(
      () => stableStringify({ userId }),
      [userId]
    );
    const state = useAsyncCache(usersCache, resolverKey, {
      suspense: true
    });
    React2.useEffect(() => warnIfNoResolveUser(usersCache), []);
    return {
      user: state.data,
      isLoading: false
    };
  }
  const mentionSuggestionsCache = createAsyncCache(
    resolveMentionSuggestions ? (stringifiedOptions) => {
      return resolveMentionSuggestions(
        JSON.parse(stringifiedOptions)
      );
    } : () => Promise.resolve([])
  );
  function useMentionSuggestions(search) {
    const room = useRoom();
    const debouncedSearch = useDebounce(search, 500);
    const resolverKey = React2.useMemo(
      () => debouncedSearch !== void 0 ? stableStringify({ text: debouncedSearch, roomId: room.id }) : null,
      [debouncedSearch, room.id]
    );
    const { data } = useAsyncCache(mentionSuggestionsCache, resolverKey, {
      keepPreviousDataWhileLoading: true
    });
    return data;
  }
  const bundle = {
    RoomContext,
    RoomProvider,
    useRoom,
    useStatus,
    useBatch,
    useBroadcastEvent,
    useLostConnectionListener,
    useErrorListener,
    useEventListener,
    useHistory,
    useUndo,
    useRedo,
    useCanRedo,
    useCanUndo,
    // These are just aliases. The passed-in key will define their return values.
    useList: useLegacyKey,
    useMap: useLegacyKey,
    useObject: useLegacyKey,
    useStorageRoot,
    useStorage,
    useSelf,
    useMyPresence,
    useUpdateMyPresence,
    useOthers,
    useOthersMapped,
    useOthersConnectionIds,
    useOther,
    useMutation,
    useThreads,
    useUser,
    useCreateThread,
    useEditThreadMetadata,
    useCreateComment,
    useEditComment,
    useDeleteComment,
    useAddReaction,
    useRemoveReaction,
    suspense: {
      RoomContext,
      RoomProvider,
      useRoom,
      useStatus,
      useBatch,
      useBroadcastEvent,
      useLostConnectionListener,
      useErrorListener,
      useEventListener,
      useHistory,
      useUndo,
      useRedo,
      useCanRedo,
      useCanUndo,
      // Legacy hooks
      useList: useLegacyKeySuspense,
      useMap: useLegacyKeySuspense,
      useObject: useLegacyKeySuspense,
      useStorageRoot,
      useStorage: useStorageSuspense,
      useSelf: useSelfSuspense,
      useMyPresence,
      useUpdateMyPresence,
      useOthers: useOthersSuspense,
      useOthersMapped: useOthersMappedSuspense,
      useOthersConnectionIds: useOthersConnectionIdsSuspense,
      useOther: useOtherSuspense,
      useMutation,
      useThreads: useThreadsSuspense,
      useUser: useUserSuspense,
      useCreateThread,
      useEditThreadMetadata,
      useCreateComment,
      useEditComment,
      useDeleteComment,
      useAddReaction,
      useRemoveReaction
    }
  };
  const internalBundle = {
    ...bundle,
    hasResolveMentionSuggestions: resolveMentionSuggestions !== void 0,
    useMentionSuggestions
  };
  return bundle;
}

// src/index.ts
import { shallow as shallow2 } from "@liveblocks/client";
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
export {
  ClientSideSuspense,
  createRoomContext,
  shallow2 as shallow,
  useRoomContextBundle
};
//# sourceMappingURL=index.mjs.map